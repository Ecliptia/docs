---
title: Events
description: "API reference for events in Moonlink.js"
icon: 'lucide:bell'
authors:
  - avatar: https://www.npmjs.com/npm-avatar/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdmF0YXJVUkwiOiJodHRwczovL3MuZ3JhdmF0YXIuY29tL2F2YXRhci9hNmE5NDVhYjJiNzk1MjcyNzVjN2IwMWEyNWM1YzQ2NT9zaXplPTQ5NiZkZWZhdWx0PXJldHJvIn0.5hP6oyShhR-UWUi6KF-lA0cWmE_BJjvIFAwkYCGEZNo
    name: Lucas Morais Rodrigues
    username: 1Lucas1apk
    to: https://github.com/1Lucas1apk
    target: _blank
---

Moonlink.js emits various events that you can listen to in order to react to changes in the state of players, nodes, and tracks. These events are essential for creating an interactive and responsive music bot.

::alert{type="info" icon="lucide:info"}
All events are emitted by the `Manager` object. You can listen to these events using the `on()` or `once()` method.
::

## Listening to Events

To listen to events, you can use the `on()` method of the `Manager`:

```js
// Create the Manager
const manager = new Manager({
  // ... options
});

// Listen to an event
manager.on('trackStart', (player, track) => {
  console.log(`Now playing: ${track.title}`);
});
```

## Debug Events

#### debug
::field{name="debug" type="event"}
::stack
::card
---
  icon: 'lucide:bug'
---
#title
  Debug

#description
  Emitted when debug information is available.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="args" type="any[]" required}
    Debug arguments
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('debug', (...args) => {
    console.log('[DEBUG]', {
      timestamp: new Date().toISOString(),
      info: args
    });
});
```

```js
  [DEBUG] {
    timestamp: "2024-03-15T12:34:56.789Z",
    info: ["Connecting to node", "Node-1", { host: "localhost", port: 2333 }]
  }
  ```

  #footer
  Use this event during development for detailed debugging information.
  ::
::
::

#### autoLeaved
::field{name="autoLeaved" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:log-out'
  ---
  #title
  Auto Leaved

  #description
  Emitted when a player automatically leaves a voice channel.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="player" type="Player" required}
    The player that left
    ::
    ::field{name="track" type="Track" required}
    The track that was playing
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('autoLeaved', (player, track) => {
    console.log(`[AUTO] Player left:`, {
      guild: player.guildId,
      track: {
        title: track.title,
        author: track.author
      },
      channel: player.voiceChannelId
    });

    const embed = new EmbedBuilder()
      .setColor('#ff6b6b')
      .setTitle('üö™ Auto Leave')
      .setDescription(`Left voice channel due to inactivity while playing **${track.title}**`);

    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) {
      channel.send({ embeds: [embed] });
    }
  });
  ```

```js
  [AUTO] Player left: {
    guild: "123456789012345678",
    track: {
      title: "Never Gonna Give You Up",
      author: "Rick Astley"
    },
    channel: "123456789012345678"
  }
  ```

  #footer
  Use this event to handle automatic disconnections and cleanup.
  ::
::
::

## Node Events

#### nodeCreate
::field{name="nodeCreate" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:plus-circle'
  ---
  #title
  Node Create

  #description
Emitted when a new node is created.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="node" type="Node" required}
    The created node
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
manager.on('nodeCreate', (node) => {
    console.log(`[NODE] New node created:`, {
      identifier: node.identifier,
      host: node.host,
      port: node.port,
      secure: node.secure
    });

    const embed = new EmbedBuilder()
      .setColor('#4ade80')
      .setTitle('üÜï Node Created')
      .setDescription(`New node ${node.identifier} created at ${node.host}:${node.port}`);

    // Notify admin channel
    const adminChannel = client.channels.cache.get('ADMIN_CHANNEL_ID');
    if (adminChannel) {
      adminChannel.send({ embeds: [embed] });
    }
  });
  ```

```js
  [NODE] New node created: {
    identifier: "Node-1",
    host: "localhost",
    port: 2333,
    secure: false
  }
  ```

  #footer
  Monitor node creation for system setup and maintenance.
  ::
::
::

#### nodeReady
::field{name="nodeReady" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:check-circle'
  ---
  #title
  Node Ready

  #description
  Emitted when a node is ready.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="node" type="Node" required}
    The ready node
    ::
    ::field{name="stats" type="INodeStats" required}
    The node statistics
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('nodeReady', (node, stats) => {
    console.log(`Node ${node.identifier} is ready`, stats);
});
```

  ```js
  [NODE] Node-1 is ready {
    players: 5,
    cpu: 0.5,
    memory: {
      free: 1000000000,
      used: 500000000,
      allocated: 1500000000
    }
  }
  ```

#footer
  Monitor node readiness for system monitoring.
  ::
::
::

#### nodeConnected
::field{name="nodeConnected" type="event"}
::stack
::card
---
  icon: 'lucide:plug'
---
#title
  Node Connected

#description
  Emitted when a node successfully connects.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="node" type="Node" required}
    The connected node
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('nodeConnected', (node) => {
    console.log(`Node ${node.identifier} connected`);
});
```

  ```js
  [NODE] Node-1 connected
  ```

  #footer
  Track node connections for system monitoring.
  ::
::
::

#### nodeError
::field{name="nodeError" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:alert-triangle'
  ---
  #title
  Node Error

  #description
  Emitted when a node encounters an error.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="node" type="Node" required}
    The node that encountered the error
    ::
    ::field{name="error" type="Error" required}
    The error that occurred
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('nodeError', (node, error) => {
    console.log(`[NODE] Error occurred:`, {
      identifier: node.identifier,
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      }
    });

    const embed = new EmbedBuilder()
      .setColor('#ef4444')
      .setTitle('‚ö†Ô∏è Node Error')
      .setDescription(`Error on node ${node.identifier}\n\`\`\`\n${error.message}\n\`\`\``);

    // Notify admin channel
    const adminChannel = client.channels.cache.get('ADMIN_CHANNEL_ID');
    if (adminChannel) {
      adminChannel.send({ embeds: [embed] });
    }
  });
  ```

```js
  [NODE] Error occurred: {
    identifier: "Node-1",
    error: {
      name: "Error",
      message: "Failed to connect to Lavalink server",
      stack: "Error: Failed to connect..."
    }
  }
  ```

  #footer
  Handle node errors to maintain system stability.
  ::
::
::

#### nodeReconnect
::field{name="nodeReconnect" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:refresh-cw'
  ---
  #title
  Node Reconnect

  #description
  Emitted when a node attempts to reconnect.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="node" type="Node" required}
    The node attempting to reconnect
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('nodeReconnect', (node) => {
    console.log(`[NODE] Reconnection attempt:`, {
      identifier: node.identifier,
      attempt: node.reconnectAttempts,
      timeout: node.reconnectTimeout
    });

    const embed = new EmbedBuilder()
      .setColor('#fbbf24')
      .setTitle('üîÑ Node Reconnecting')
      .setDescription(`Node ${node.identifier} is attempting to reconnect\nAttempt: ${node.reconnectAttempts}`);

    // Notify admin channel
    const adminChannel = client.channels.cache.get('ADMIN_CHANNEL_ID');
    if (adminChannel) {
      adminChannel.send({ embeds: [embed] });
    }
  });
  ```

```js
  [NODE] Reconnection attempt: {
    identifier: "Node-1",
    attempt: 1,
    timeout: 5000
  }
  ```

  #footer
  Monitor reconnection attempts to ensure node stability.
  ::
::
::

#### nodeDisconnect
::field{name="nodeDisconnect" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:wifi-off'
  ---
  #title
  Node Disconnect

  #description
  Emitted when a node disconnects.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="node" type="Node" required}
    The disconnected node
    ::
    ::field{name="code" type="number" required}
    Disconnect code
    ::
    ::field{name="reason" type="string" required}
    Disconnect reason
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('nodeDisconnect', (node, code, reason) => {
    console.log(`[NODE] Disconnected:`, {
      identifier: node.identifier,
      code: code,
      reason: reason,
      reconnecting: node.reconnecting
    });

    const embed = new EmbedBuilder()
      .setColor('#ef4444')
      .setTitle('üîå Node Disconnected')
      .setDescription(`Node ${node.identifier} disconnected\nCode: ${code}\nReason: ${reason}`);

    // Notify admin channel
    const adminChannel = client.channels.cache.get('ADMIN_CHANNEL_ID');
    if (adminChannel) {
      adminChannel.send({ embeds: [embed] });
    }
});
```

  ```js
  [NODE] Disconnected: {
    identifier: "Node-1",
    code: 1006,
    reason: "Connection closed abnormally",
    reconnecting: true
  }
  ```

#footer
  Handle node disconnections to maintain service reliability.
  ::
::
::

#### nodeDestroy
::field{name="nodeDestroy" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:trash-2'
  ---
  #title
  Node Destroy

  #description
  Emitted when a node is destroyed.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="node" type="Node" required}
    The destroyed node
    ::
  ::
  ::

::card
---
  icon: 'lucide:code'
---
#title
  Usage Example

#description
  ```js
  manager.on('nodeDestroy', (node) => {
    console.log(`[NODE] Destroyed:`, {
      identifier: node.identifier,
      timestamp: new Date().toISOString()
    });

    const embed = new EmbedBuilder()
      .setColor('#ef4444')
      .setTitle('üí• Node Destroyed')
      .setDescription(`Node ${node.identifier} has been destroyed`);

    // Notify admin channel
    const adminChannel = client.channels.cache.get('ADMIN_CHANNEL_ID');
    if (adminChannel) {
      adminChannel.send({ embeds: [embed] });
    }
  });
  ```

```js
  [NODE] Destroyed: {
    identifier: "Node-1",
    timestamp: "2024-03-15T12:34:56.789Z"
  }
  ```

  #footer
  Use this event to handle cleanup after node destruction.
  ::
::
::

#### nodeAutoResumed
::field{name="nodeAutoResumed" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:rotate-ccw'
  ---
  #title
  Node Auto Resumed

  #description
  Emitted when a node automatically resumes its players.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="node" type="Node" required}
    The node that resumed
    ::
    ::field{name="players" type="Player[]" required}
    Array of resumed players
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('nodeAutoResumed', (node, players) => {
    console.log(`[NODE] Auto-resumed:`, {
      identifier: node.identifier,
      playersCount: players.length,
      players: players.map(p => ({
        guild: p.guildId,
        track: p.queue.current?.title
      }))
    });

    const embed = new EmbedBuilder()
      .setColor('#4ade80')
      .setTitle('‚ôªÔ∏è Players Resumed')
      .setDescription(`${players.length} players resumed on node ${node.identifier}`);

    // Notify players about resumption
    players.forEach(player => {
      const channel = client.channels.cache.get(player.textChannelId);
      if (channel) {
        channel.send('‚úÖ Player resumed after node reconnection');
      }
    });
  });
  ```

```js
  [NODE] Auto-resumed: {
    identifier: "Node-1",
    playersCount: 2,
    players: [
      {
        guild: "123456789012345678",
        track: "Never Gonna Give You Up"
      },
      {
        guild: "876543210987654321",
        track: "Despacito"
      }
    ]
  }
  ```

  #footer
  Handle automatic player resumption after node reconnection.
  ::
::
::

## Player Events

#### playerCreate
::field{name="playerCreate" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:plus-circle'
  ---
  #title
  Player Create

  #description
  Emitted when a new player is created.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="player" type="Player" required}
    The created player
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('playerCreate', (player) => {
    console.log(`[PLAYER] Created:`, {
      guild: player.guildId,
      node: player.node.identifier,
      voiceChannel: player.voiceChannelId,
      textChannel: player.textChannelId
    });

    const embed = new EmbedBuilder()
      .setColor('#4ade80')
      .setTitle('üéµ Player Created')
      .setDescription(`Music player created in <#${player.voiceChannelId}>`);

    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) {
      channel.send({ embeds: [embed] });
    }
  });
  ```

```js
  [PLAYER] Created: {
    guild: "123456789012345678",
    node: "Node-1",
    voiceChannel: "123456789012345678",
    textChannel: "876543210987654321"
  }
  ```

  #footer
  Initialize player settings and setup event handlers.
  ::
::
::

#### playerUpdate
::field{name="playerUpdate" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:refresh'
  ---
  #title
  Player Update

  #description
  Emitted when a player is updated.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="player" type="Player" required}
    The updated player
    ::
    ::field{name="track" type="Track" required}
    The updated track
    ::
    ::field{name="payload" type="any" required}
    The payload data
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('playerUpdate', (player, track, payload) => {
    console.log(`Player updated: ${player.guildId}`, payload);
});
```

  ```js
  [PLAYER] Updated: {
    guild: "123456789012345678",
    track: {
      title: "Never Gonna Give You Up",
      author: "Rick Astley"
    },
    payload: {
      volume: 1.0,
      loop: false,
      autoplay: true
    }
  }
  ```

#footer
  Handle player updates and implement additional logic if needed.
  ::
::
::

#### playerDestroy
::field{name="playerDestroy" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:trash-2'
  ---
  #title
  Player Destroy

  #description
  Emitted when a player is destroyed.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="player" type="Player" required}
    The destroyed player
    ::
  ::
  ::

::card
---
  icon: 'lucide:code'
---
#title
  Usage Example

#description
  ```js
  manager.on('playerDestroy', (player) => {
    console.log(`[PLAYER] Destroyed:`, {
      guild: player.guildId,
      node: player.node.identifier,
      reason: player.state
    });

    const embed = new EmbedBuilder()
      .setColor('#ef4444')
      .setTitle('üëã Player Destroyed')
      .setDescription('Music player has been destroyed');

    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) {
      channel.send({ embeds: [embed] });
    }

    // Cleanup any resources
    player.queue.clear();
});
```

  ```js
  [PLAYER] Destroyed: {
    guild: "123456789012345678",
    node: "Node-1",
    reason: "disconnected"
  }
  ```

#footer
  Clean up resources and notify users when a player is destroyed.
  ::
::
::

#### playerSwitchedNode
::field{name="playerSwitchedNode" type="event"}
::stack
::card
---
  icon: 'lucide:move'
---
#title
  Player Switched Node

#description
  Emitted when a player switches to a different node.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="player" type="Player" required}
    The player that switched
    ::
    ::field{name="oldNode" type="Node" required}
    The previous node
    ::
    ::field{name="newNode" type="Node" required}
    The new node
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('playerSwitchedNode', (player, oldNode, newNode) => {
    console.log(`Player switched from node ${oldNode.identifier} to ${newNode.identifier}`);
});
```

  ```js
  [PLAYER] Switched node: {
    guild: "123456789012345678",
    oldNode: "Node-1",
    newNode: "Node-2"
  }
  ```

  #footer
  Handle node switches to maintain playback continuity.
  ::
::
::

## Player Control Events

#### playerTriggeredPlay
::field{name="playerTriggeredPlay" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:play'
  ---
  #title
  Player Triggered Play

  #description
  Emitted when a player starts playing.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="player" type="Player" required}
    The player that started playing
    ::
    ::field{name="track" type="Track" required}
    The track that started playing
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('playerTriggeredPlay', (player, track) => {
    console.log(`Player started playing: ${track.title}`);
});
```

  ```js
  [PLAYER] Started playing: {
    guild: "123456789012345678",
    track: {
      title: "Never Gonna Give You Up",
      author: "Rick Astley"
    }
  }
  ```

#footer
  Handle player start events and implement additional logic if needed.
  ::
::
::

#### playerTriggeredPause
::field{name="playerTriggeredPause" type="event"}
::stack
::card
---
  icon: 'lucide:pause'
---
#title
  Player Triggered Pause

#description
  Emitted when a player is paused.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="player" type="Player" required}
    The player that was paused
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('playerTriggeredPause', (player) => {
    console.log(`Player paused: ${player.guildId}`);
});
```

```js
  [PLAYER] Paused: {
    guild: "123456789012345678"
  }
  ```

  #footer
  Handle player pause events and implement additional logic if needed.
  ::
::
::

#### playerTriggeredResume
::field{name="playerTriggeredResume" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:play'
  ---
  #title
  Player Triggered Resume

  #description
  Emitted when a player resumes playing.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="player" type="Player" required}
    The player that resumed playing
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('playerTriggeredResume', (player) => {
    console.log(`Player resumed: ${player.guildId}`);
});
```

  ```js
  [PLAYER] Resumed: {
    guild: "123456789012345678"
  }
  ```

  #footer
  Handle player resume events and implement additional logic if needed.
  ::
::
::

#### playerTriggeredStop
::field{name="playerTriggeredStop" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:stop'
  ---
  #title
  Player Triggered Stop

  #description
  Emitted when a player stops playing.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="player" type="Player" required}
    The player that stopped playing
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('playerTriggeredStop', (player) => {
    console.log(`Player stopped: ${player.guildId}`);
});
```

  ```js
  [PLAYER] Stopped: {
    guild: "123456789012345678"
  }
  ```

#footer
  Handle WebSocket errors and implement recovery strategies.
  ::
::
::

## Filter Events

#### filterUpdate
::field{name="filterUpdate" type="event"}
::stack
::card
---
  icon: 'lucide:equalizer'
---
#title
  Filter Update

#description
  Emitted when audio filters are updated.
  <br>
  <h5>Parameters</h5>

  ::field-group
    ::field{name="player" type="Player" required}
    The player whose filters were updated
    ::
    ::field{name="filters" type="Filters" required}
    The updated filters object
    ::
  ::
  ::

  ::card
  ---
  icon: 'lucide:code'
  ---
  #title
  Usage Example

  #description
```js
  manager.on('filterUpdate', (player, filters) => {
    console.log(`[FILTER] Updated:`, {
      guild: player.guildId,
      filters: {
        volume: filters.volume,
        equalizer: filters.equalizer,
        karaoke: filters.karaoke,
        timescale: filters.timescale,
        tremolo: filters.tremolo,
        vibrato: filters.vibrato,
        rotation: filters.rotation,
        distortion: filters.distortion,
        channelMix: filters.channelMix,
        lowPass: filters.lowPass
      }
    });

    const embed = new EmbedBuilder()
      .setColor('#fbbf24')
      .setTitle('üéõÔ∏è Filters Updated')
      .setDescription('Audio filters have been updated')
      .addFields(
        Object.entries(filters)
          .filter(([_, value]) => value !== null && value !== undefined)
          .map(([key, value]) => ({
            name: key.charAt(0).toUpperCase() + key.slice(1),
            value: typeof value === 'object' ? 'Applied' : String(value),
            inline: true
          }))
      );

    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) {
      channel.send({ embeds: [embed] });
    }
});
```

  ```js
  [FILTER] Updated: {
    guild: "123456789012345678",
    filters: {
      volume: 1.0,
      equalizer: [
        { band: 0, gain: 0.2 },
        { band: 1, gain: 0.15 }
      ],
      karaoke: null,
      timescale: { speed: 1.1, pitch: 1.0, rate: 1.0 },
      tremolo: null,
      vibrato: null,
      rotation: null,
      distortion: null,
      channelMix: null,
      lowPass: null
    }
  }
  ```

#footer
  Monitor and display audio filter changes.
  ::
::
::

## Events

#### playerTriggeredSkip
::field{name="playerTriggeredSkip" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:skip-forward'
  ---
  #title
  Player Triggered Skip

  #description
  Emitido quando uma track √© pulada.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `oldTrack: Record<string, any>` - Track anterior
  - `currentTrack: Track` - Nova track
  - `position: number` - Posi√ß√£o atual
  
  ```js
  manager.on('playerTriggeredSkip', (player, oldTrack, currentTrack, position) => {
    console.log(`Track pulada: ${oldTrack.title} -> ${currentTrack.title} (Posi√ß√£o: ${position})`);
    
    const embed = new EmbedBuilder()
      .setColor('#fbbf24')
      .setTitle('‚è≠Ô∏è Track Pulada')
      .setDescription(`Pulou **${oldTrack.title}**\nAgora tocando: **${currentTrack.title}**`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### playerTriggeredSeek
::field{name="playerTriggeredSeek" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:forward'
  ---
  #title
  Player Triggered Seek

  #description
  Emitido quando a posi√ß√£o da track √© alterada.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `position: number` - Nova posi√ß√£o em milissegundos
  
  ```js
  manager.on('playerTriggeredSeek', (player, position) => {
    const timeString = new Date(position).toISOString().substr(11, 8);
    console.log(`Posi√ß√£o alterada para ${timeString}`);
    
    const embed = new EmbedBuilder()
      .setColor('#fbbf24')
      .setTitle('‚è© Posi√ß√£o Alterada')
      .setDescription(`Avan√ßou para ${timeString}`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### playerTriggeredShuffle
::field{name="playerTriggeredShuffle" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:shuffle'
  ---
  #title
  Player Triggered Shuffle

  #description
  Emitido quando a fila √© embaralhada.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `oldQueue: Record<string, any>` - Fila anterior
  - `currentQueue: Track[]` - Nova fila
  
  ```js
  manager.on('playerTriggeredShuffle', (player, oldQueue, currentQueue) => {
    console.log(`Fila embaralhada: ${currentQueue.length} tracks`);
    
    const embed = new EmbedBuilder()
      .setColor('#fbbf24')
      .setTitle('üîÄ Fila Embaralhada')
      .setDescription(`${currentQueue.length} tracks na fila`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### playerChangedVolume
::field{name="playerChangedVolume" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:volume-2'
  ---
  #title
  Player Changed Volume

  #description
  Emitido quando o volume √© alterado.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `oldVolume: number` - Volume anterior
  - `volume: number` - Novo volume
  
  ```js
  manager.on('playerChangedVolume', (player, oldVolume, volume) => {
    console.log(`Volume alterado: ${oldVolume} -> ${volume}`);
    
    const embed = new EmbedBuilder()
      .setColor('#fbbf24')
      .setTitle('üîä Volume Alterado')
      .setDescription(`Volume: ${volume}%`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### playerChangedLoop
::field{name="playerChangedLoop" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:repeat'
  ---
  #title
  Player Changed Loop

  #description
  Emitido quando o modo de loop √© alterado.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `oldLoop: TPlayerLoop` - Modo anterior
  - `loop: TPlayerLoop` - Novo modo
  
  ```js
  manager.on('playerChangedLoop', (player, oldLoop, loop) => {
    console.log(`Loop alterado: ${oldLoop} -> ${loop}`);
    
    const embed = new EmbedBuilder()
      .setColor('#fbbf24')
      .setTitle('üîÅ Loop Alterado')
      .setDescription(`Modo: ${loop}`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### playerAutoPlaySet
::field{name="playerAutoPlaySet" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:music'
  ---
  #title
  Player Auto Play Set

  #description
  Emitido quando o autoplay √© alterado.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `autoPlay: boolean` - Novo estado
  
  ```js
  manager.on('playerAutoPlaySet', (player, autoPlay) => {
    console.log(`Autoplay ${autoPlay ? 'ativado' : 'desativado'}`);
    
    const embed = new EmbedBuilder()
      .setColor('#fbbf24')
      .setTitle('üéµ Autoplay')
      .setDescription(`Autoplay ${autoPlay ? 'ativado' : 'desativado'}`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### playerAutoLeaveSet
::field{name="playerAutoLeaveSet" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:log-out'
  ---
  #title
  Player Auto Leave Set

  #description
  Emitido quando o autoleave √© alterado.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `autoLeave: boolean` - Novo estado
  
  ```js
  manager.on('playerAutoLeaveSet', (player, autoLeave) => {
    console.log(`Autoleave ${autoLeave ? 'ativado' : 'desativado'}`);
    
    const embed = new EmbedBuilder()
      .setColor('#fbbf24')
      .setTitle('üëã Auto Leave')
      .setDescription(`Auto leave ${autoLeave ? 'ativado' : 'desativado'}`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### playerTextChannelIdSet
::field{name="playerTextChannelIdSet" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:message-square'
  ---
  #title
  Player Text Channel ID Set

  #description
  Emitido quando o canal de texto √© alterado.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `oldChannel: string` - Canal anterior
  - `newChannel: string` - Novo canal
  
  ```js
  manager.on('playerTextChannelIdSet', (player, oldChannel, newChannel) => {
    console.log(`Canal de texto alterado: ${oldChannel} -> ${newChannel}`);
  });
  ```
  ::
::

#### playerVoiceChannelIdSet
::field{name="playerVoiceChannelIdSet" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:mic'
  ---
  #title
  Player Voice Channel ID Set

  #description
  Emitido quando o canal de voz √© alterado.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `oldChannel: string` - Canal anterior
  - `newChannel: string` - Novo canal
  
  ```js
  manager.on('playerVoiceChannelIdSet', (player, oldChannel, newChannel) => {
    console.log(`Canal de voz alterado: ${oldChannel} -> ${newChannel}`);
  });
  ```
  ::
::

#### playerNodeSet
::field{name="playerNodeSet" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:server'
  ---
  #title
  Player Node Set

  #description
  Emitido quando o node do player √© alterado.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `oldNode: string` - Node anterior
  - `newNode: string` - Novo node
  
  ```js
  manager.on('playerNodeSet', (player, oldNode, newNode) => {
    console.log(`Node alterado: ${oldNode} -> ${newNode}`);
  });
  ```
  ::
::

#### playerConnected
::field{name="playerConnected" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:plug'
  ---
  #title
  Player Connected

  #description
  Emitido quando um player conecta.
  
  **Par√¢metros:**
  - `player: Player` - O player conectado
  
  ```js
  manager.on('playerConnected', (player) => {
    console.log(`Player conectado em ${player.guildId}`);
    
    const embed = new EmbedBuilder()
      .setColor('#4ade80')
      .setTitle('üîå Conectado')
      .setDescription(`Conectado ao canal de voz`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### playerDisconnected
::field{name="playerDisconnected" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:plug-off'
  ---
  #title
  Player Disconnected

  #description
  Emitido quando um player desconecta.
  
  **Par√¢metros:**
  - `player: Player` - O player desconectado
  
  ```js
  manager.on('playerDisconnected', (player) => {
    console.log(`Player desconectado em ${player.guildId}`);
    
    const embed = new EmbedBuilder()
      .setColor('#ef4444')
      .setTitle('üîå Desconectado')
      .setDescription(`Desconectado do canal de voz`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### playerMoved
::field{name="playerMoved" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:move'
  ---
  #title
  Player Moved

  #description
  Emitido quando um player muda de canal.
  
  **Par√¢metros:**
  - `player: Player` - O player movido
  - `oldChannel: string` - Canal anterior
  - `newChannel: string` - Novo canal
  
  ```js
  manager.on('playerMoved', (player, oldChannel, newChannel) => {
    console.log(`Player movido: ${oldChannel} -> ${newChannel}`);
    
    const embed = new EmbedBuilder()
      .setColor('#fbbf24')
      .setTitle('‚ÜîÔ∏è Canal Alterado')
      .setDescription(`Movido para <#${newChannel}>`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### playerDestroyed
::field{name="playerDestroyed" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:trash-2'
  ---
  #title
  Player Destroyed

  #description
  Emitido quando um player √© destru√≠do.
  
  **Par√¢metros:**
  - `player: Player` - O player destru√≠do
  
  ```js
  manager.on('playerDestroyed', (player) => {
    console.log(`Player destru√≠do em ${player.guildId}`);
    
    const embed = new EmbedBuilder()
      .setColor('#ef4444')
      .setTitle('üí• Player Destru√≠do')
      .setDescription(`O player foi destru√≠do`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### trackStart
::field{name="trackStart" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:music'
  ---
  #title
  Track Start

  #description
  Emitido quando uma track come√ßa a tocar.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `track: Track` - A track iniciada
  
  ```js
  manager.on('trackStart', (player, track) => {
    console.log(`Tocando: ${track.title}`);
    
    const embed = new EmbedBuilder()
      .setColor('#4ade80')
      .setTitle('üéµ Tocando Agora')
      .setDescription(`**${track.title}**`)
      .addFields(
        { name: 'Artista', value: track.author, inline: true },
        { name: 'Dura√ß√£o', value: formatTime(track.duration), inline: true }
      )
      .setThumbnail(track.artworkUrl);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### trackEnd
::field{name="trackEnd" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:music-off'
  ---
  #title
  Track End

  #description
  Emitido quando uma track termina.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `track: Track` - A track finalizada
  - `type: TTrackEndType` - Tipo de finaliza√ß√£o
  - `payload?: any` - Dados adicionais
  
  ```js
  manager.on('trackEnd', (player, track, type, payload) => {
    console.log(`Track finalizada: ${track.title} (${type})`);
    
    const embed = new EmbedBuilder()
      .setColor('#94a3b8')
      .setTitle('üéµ Track Finalizada')
      .setDescription(`**${track.title}** terminou`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### trackStuck
::field{name="trackStuck" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:alert-triangle'
  ---
  #title
  Track Stuck

  #description
  Emitido quando uma track trava.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `track: Track` - A track travada
  - `threshold: number` - Limite de tempo
  
  ```js
  manager.on('trackStuck', (player, track, threshold) => {
    console.log(`Track travou: ${track.title} (${threshold}ms)`);
    
    const embed = new EmbedBuilder()
      .setColor('#ef4444')
      .setTitle('‚ö†Ô∏è Track Travada')
      .setDescription(`**${track.title}** travou\nTempo limite: ${threshold}ms`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### trackException
::field{name="trackException" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:alert-octagon'
  ---
  #title
  Track Exception

  #description
  Emitido quando ocorre um erro na track.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `track: Track` - A track com erro
  - `exception: any` - O erro ocorrido
  
  ```js
  manager.on('trackException', (player, track, exception) => {
    console.log(`Erro na track ${track.title}:`, exception);
    
    const embed = new EmbedBuilder()
      .setColor('#ef4444')
      .setTitle('‚ùå Erro na Track')
      .setDescription(`Erro ao tocar **${track.title}**\n\`${exception.message}\``);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### queueEnd
::field{name="queueEnd" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:list-end'
  ---
  #title
  Queue End

  #description
  Emitido quando a fila termina.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `track?: any` - √öltima track tocada
  
  ```js
  manager.on('queueEnd', (player, track) => {
    console.log(`Fila finalizada em ${player.guildId}`);
    
    const embed = new EmbedBuilder()
      .setColor('#94a3b8')
      .setTitle('üéµ Fila Finalizada')
      .setDescription('Todas as tracks foram tocadas');
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

#### socketClosed
::field{name="socketClosed" type="event"}
::stack
  ::card
  ---
  icon: 'lucide:wifi-off'
  ---
  #title
  Socket Closed

  #description
  Emitido quando o socket √© fechado.
  
  **Par√¢metros:**
  - `player: Player` - O player
  - `code: number` - C√≥digo de fechamento
  - `reason: string` - Motivo do fechamento
  - `byRemote: boolean` - Se foi fechado remotamente
  
  ```js
  manager.on('socketClosed', (player, code, reason, byRemote) => {
    console.log(`Socket fechado: ${reason} (${code})`);
    
    const embed = new EmbedBuilder()
      .setColor('#ef4444')
      .setTitle('üîå Conex√£o Fechada')
      .setDescription(`Conex√£o fechada: ${reason}\nC√≥digo: ${code}`);
    
    const channel = client.channels.cache.get(player.textChannelId);
    if (channel) channel.send({ embeds: [embed] });
  });
  ```
  ::
::

::button-link{right-icon="lucide:arrow-right" to="/api/errors"}
  Continue to Errors
:: 