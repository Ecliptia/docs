---
title: Command Handling
description: A consistent command pattern (aliases, validations, and predictable replies).
icon: lucide:terminal
---

You already have a dispatcher in `messageCreate`, but the real quality of a music bot comes from having **consistent command behavior**.

This page sets a simple standard:

- one file per command
- optional aliases
- predictable validations (same voice channel, player exists, etc.)
- clean error handling

## The command shape

A typical command module looks like this:

```js
module.exports = {
  name: "play",
  aliases: ["p"],
  description: "Play a song",
  async execute(message, args, client) {
    // command logic
  },
};
```

## Registering aliases (recommended)

When loading commands, register both the command name and its aliases into the same `Collection`.

```js
client.commands.set(command.name, command);

if (Array.isArray(command.aliases)) {
  for (const alias of command.aliases) {
    client.commands.set(alias, command);
  }
}
```

::alert{type="note" icon="lucide:info"}
With this approach, `client.commands.get('play')` and `client.commands.get('p')` return the same module.
::

## Music command validations you should repeat on purpose

A good music command almost always checks:

- **Is the user in a voice channel?**
- **Is there an active player for this guild?**
- **Is the user in the same voice channel as the player?**
- **Is there a current track (when needed)?**

This isn’t “boilerplate to avoid” — it’s protection against the most common support questions.

::alert{type="success" icon="lucide:lightbulb"}
Consistency beats cleverness. Users learn quickly when commands always behave the same way.
::
