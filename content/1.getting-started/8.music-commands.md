---
title: Music Commands (Complete)
description: "A full set of music commands (not simplified): play, queue, filters, seek, volume, and more."
icon: lucide:music
---

This page provides a **complete**, practical command set. These commands are intentionally verbose and explicit, so you can read them like a lesson and extend them safely.

::alert{type="note" icon="lucide:info"}
All examples below are based on the structure from previous pages (`commands/`, `events/`, loaders in `index.js`).
::

## commands/join.js

```js
module.exports = {
  name: "join",
  aliases: ["connect", "j"],
  description: "Join your voice channel",
  async execute(message, args, client) {
    const { channel } = message.member.voice;
    if (!channel) {
      return message.reply("You need to join a voice channel first!");
    }

    const existingPlayer = client.manager.players.get(message.guild.id);
    if (existingPlayer && existingPlayer.voiceChannelId) {
      if (existingPlayer.voiceChannelId === channel.id) {
        return message.reply("I'm already in your voice channel!");
      }
      return message.reply(`I'm already connected to <#${existingPlayer.voiceChannelId}>!`);
    }

    const player = client.manager.players.create({
      guildId: message.guild.id,
      voiceChannelId: channel.id,
      textChannelId: message.channel.id,
      autoPlay: true,
    });

    await player.connect();
    return message.reply(`Successfully joined <#${channel.id}>!`);
  },
};
```

## commands/play.js

```js
module.exports = {
  name: "play",
  description: "Play a song",
  async execute(message, args, client) {
    const { channel } = message.member.voice;
    if (!channel) {
      return message.reply("You need to join a voice channel first!");
    }

    if (!args.length) {
      return message.reply("Please provide a song to play!");
    }

    // Create or get an existing player for this guild
    const player = client.manager.players.create({
      guildId: message.guild.id,
      voiceChannelId: channel.id,
      textChannelId: message.channel.id,
      autoPlay: true,
    });

    // Ensure we are connected
    await player.connect();

    // Search
    const query = args.join(" ");
    const searchResult = await client.manager.search({
      query,
      requester: message.author.id,
    });

    if (!searchResult.tracks.length) {
      return message.reply("No results found for your query.");
    }

    // Handle different load types
    switch (searchResult.loadType) {
      case "playlist":
        player.queue.add(searchResult.tracks);
        await message.reply(
          `Added playlist **${searchResult.playlistInfo.name}** with ${searchResult.tracks.length} tracks to the queue.`
        );
        if (!player.playing) await player.play();
        break;

      case "search":
      case "track":
        await player.queue.add(searchResult.tracks[0]);
        await message.reply(`Added **${searchResult.tracks[0].title}** to the queue.`);
        if (!player.playing) await player.play();
        break;

      case "empty":
        await message.reply("No matches found for your query!");
        break;

      case "error":
        await message.reply(
          `An error occurred while loading the track: ${searchResult.error || "Unknown error"}`
        );
        break;
    }
  },
};
```

## commands/pause.js

```js
module.exports = {
  name: "pause",
  description: "Pause the current song",
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply("There is nothing playing in this server!");
    }

    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply(
        "You need to be in the same voice channel as the bot to use this command!"
      );
    }

    if (player.paused) {
      return message.reply("The player is already paused!");
    }

    player.pause();
    return message.reply("Paused the player.");
  },
};
```

## commands/resume.js

```js
module.exports = {
  name: "resume",
  description: "Resume playback if paused",
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply("There is nothing playing in this server!");
    }

    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply(
        "You need to be in the same voice channel as the bot to use this command!"
      );
    }

    if (!player.paused) {
      return message.reply("The player is not paused!");
    }

    player.resume();
    return message.reply("Resumed playback.");
  },
};
```

## commands/skip.js

```js
module.exports = {
  name: "skip",
  description: "Skip the current song",
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply("There is nothing playing in this server!");
    }

    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply(
        "You need to be in the same voice channel as the bot to use this command!"
      );
    }

    if (!player.current) {
      return message.reply("There is nothing playing right now!");
    }

    const currentTrack = player.current;
    player.skip();

    return message.reply(`Skipped: **${currentTrack.title}**`);
  },
};
```

## commands/stop.js

```js
module.exports = {
  name: "stop",
  description: "Stop playback and clear the queue",
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply("There is nothing playing in this server!");
    }

    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply(
        "You need to be in the same voice channel as the bot to use this command!"
      );
    }

    player.stop();
    player.queue.clear();

    return message.reply("Stopped playback and cleared the queue.");
  },
};
```

## commands/queue.js

```js
const { EmbedBuilder } = require("discord.js");

module.exports = {
  name: "queue",
  description: "Show the current queue",
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply("There is nothing playing in this server!");
    }

    if (!player.current && player.queue.size === 0) {
      return message.reply("There are no tracks in the queue!");
    }

    const formatDuration = (ms) => {
      const seconds = Math.floor((ms / 1000) % 60);
      const minutes = Math.floor((ms / (1000 * 60)) % 60);
      const hours = Math.floor(ms / (1000 * 60 * 60));

      return `${hours ? `${hours}:` : ""}${minutes.toString().padStart(2, "0")}:${seconds
        .toString()
        .padStart(2, "0")}`;
    };

    const embed = new EmbedBuilder().setTitle("Current Queue").setColor("#0099ff");

    if (player.current) {
      embed.setDescription(
        `**Now Playing:**\n[${player.current.title}](${player.current.uri}) | \`${formatDuration(
          player.current.duration
        )}\``
      );
    }

    if (player.queue.size > 0) {
      const tracks = player.queue.tracks.map((track, index) => {
        return `${index + 1}. [${track.title}](${track.uri}) | \`${formatDuration(track.duration)}\``;
      });

      embed.addFields({
        name: "Up Next:",
        value: tracks.slice(0, 10).join("\n"),
      });

      if (player.queue.size > 10) {
        embed.addFields({
          name: "And more...",
          value: `${player.queue.size - 10} more tracks in the queue`,
        });
      }
    }

    return message.reply({ embeds: [embed] });
  },
};
```

## commands/nowplaying.js

```js
const { EmbedBuilder } = require("discord.js");

module.exports = {
  name: "nowplaying",
  aliases: ["np", "current"],
  description: "Show information about the current track",
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) return message.reply("No active player!");
    if (!player.current) return message.reply("Nothing is playing!");

    const track = player.current;

    const formatDuration = (ms) => {
      const seconds = Math.floor((ms / 1000) % 60);
      const minutes = Math.floor((ms / (1000 * 60)) % 60);
      const hours = Math.floor(ms / (1000 * 60 * 60));

      return `${hours ? `${hours}:` : ""}${minutes.toString().padStart(2, "0")}:${seconds
        .toString()
        .padStart(2, "0")}`;
    };

    const createProgressBar = (current, total, length = 15) => {
      const progress = Math.round((current / total) * length);
      return "‚ñ¨".repeat(progress) + "üîò" + "‚ñ¨".repeat(length - progress);
    };

    const embed = new EmbedBuilder()
      .setTitle("Now Playing")
      .setColor("#0099ff")
      .setDescription(`[${track.title}](${track.uri})`)
      .addFields(
        { name: "Author", value: track.author, inline: true },
        {
          name: "Requested By",
          value: `<@${track.userData.requester}>`,
          inline: true,
        },
        {
          name: "Duration",
          value: `\`${formatDuration(track.position)} / ${formatDuration(track.duration)}\`\n${createProgressBar(
            track.position,
            track.duration
          )}`,
        }
      );

    if (track.artworkUrl) {
      embed.setThumbnail(track.artworkUrl);
    }

    return message.reply({ embeds: [embed] });
  },
};
```

## commands/volume.js

```js
module.exports = {
  name: "volume",
  aliases: ["vol", "v"],
  description: "Adjust the player volume",
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) return message.reply("No active player!");

    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply("You must be in the same voice channel!");
    }

    if (!args.length) {
      return message.reply(`Current volume is: **${player.volume}%**`);
    }

    const volume = parseInt(args[0]);

    if (isNaN(volume)) {
      return message.reply("Please provide a valid number!");
    }

    if (volume < 0 || volume > 1000) {
      return message.reply("Volume must be between 0 and 1000!");
    }

    player.setVolume(volume);
    return message.reply(`Volume set to: **${volume}%**`);
  },
};
```

## commands/seek.js

```js
module.exports = {
  name: "seek",
  aliases: ["jump", "goto"],
  description: "Seek to a specific position in the current track",
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) return message.reply("No active player!");

    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply("You must be in the same voice channel!");
    }

    if (!player.current) return message.reply("Nothing is playing!");
    if (!player.current.isSeekable) return message.reply("This track cannot be seeked!");

    if (!args.length) {
      return message.reply("Provide a position (e.g., 1:30 or 90)");
    }

    const position = args[0];
    let milliseconds = 0;

    if (position.includes(":")) {
      const [minutes, seconds] = position.split(":");
      milliseconds = (parseInt(minutes) * 60 + parseInt(seconds)) * 1000;
    } else {
      milliseconds = parseInt(position) * 1000;
    }

    if (isNaN(milliseconds)) return message.reply("Invalid time format!");

    if (milliseconds > player.current.duration) {
      return message.reply(`Track is only ${formatDuration(player.current.duration)} long!`);
    }

    player.seek(milliseconds);
    return message.reply(`Seeked to: **${formatDuration(milliseconds)}**`);
  },
};

function formatDuration(ms) {
  const seconds = Math.floor((ms / 1000) % 60);
  const minutes = Math.floor((ms / (1000 * 60)) % 60);
  const hours = Math.floor(ms / (1000 * 60 * 60));

  return `${hours ? `${hours}:` : ""}${minutes.toString().padStart(2, "0")}:${seconds
    .toString()
    .padStart(2, "0")}`;
}
```

## commands/filter.js

```js
module.exports = {
  name: "filter",
  aliases: ["effect", "fx"],
  description: "Apply an audio filter",
  async execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) return message.reply("No active player!");

    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply("You must be in the same voice channel!");
    }

    if (!args.length) {
      return message.reply(
        "Available filters: `reset`, `bassboost`, `nightcore`, `vaporwave`, `8d`, `tremolo`, `vibrato`, `karaoke`"
      );
    }

    const filter = args[0].toLowerCase();
    let filterApplied = false;
    let replyMessage = "";

    try {
      switch (filter) {
        case "reset":
          player.filters.resetFilters();
          filterApplied = true;
          replyMessage = "All filters reset.";
          break;

        case "bassboost":
          player.filters.setEqualizer([
            { band: 0, gain: 0.6 },
            { band: 1, gain: 0.7 },
            { band: 2, gain: 0.8 },
            { band: 3, gain: 0.55 },
            { band: 4, gain: 0.25 },
          ]);
          filterApplied = true;
          replyMessage = "Bassboost filter applied.";
          break;

        case "nightcore":
          player.filters.setTimescale({ speed: 1.2, pitch: 1.2, rate: 1.0 });
          filterApplied = true;
          replyMessage = "Nightcore filter applied.";
          break;

        case "vaporwave":
          player.filters.setTimescale({ speed: 0.8, pitch: 0.8, rate: 1.0 });
          filterApplied = true;
          replyMessage = "Vaporwave filter applied.";
          break;

        case "8d":
          player.filters.setRotation({ rotationHz: 0.2 });
          filterApplied = true;
          replyMessage = "8D filter applied.";
          break;

        case "tremolo":
          player.filters.setTremolo({ frequency: 4.0, depth: 0.75 });
          filterApplied = true;
          replyMessage = "Tremolo filter applied.";
          break;

        case "vibrato":
          player.filters.setVibrato({ frequency: 4.0, depth: 0.75 });
          filterApplied = true;
          replyMessage = "Vibrato filter applied.";
          break;

        case "karaoke":
          player.filters.setKaraoke({
            level: 1.0,
            monoLevel: 1.0,
            filterBand: 220.0,
            filterWidth: 100.0,
          });
          filterApplied = true;
          replyMessage = "Karaoke filter applied.";
          break;

        default:
          return message.reply(
            "Invalid filter! Available filters: `reset`, `bassboost`, `nightcore`, `vaporwave`, `8d`, `tremolo`, `vibrato`, `karaoke`"
          );
      }

      if (filterApplied) {
        await player.filters.apply();
        return message.reply(replyMessage);
      }
    } catch (error) {
      console.error("Filter application error:", error);
      return message.reply("Failed to apply filter. Please try again.");
    }
  },
};
```

## commands/autoplay.js

```js
module.exports = {
  name: "autoplay",
  aliases: ["ap", "auto"],
  description: "Toggle autoplay for the current player",
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply("There is no active player for this server.");
    }

    const { channel } = message.member.voice;
    if (!channel) {
      return message.reply("You need to join a voice channel first!");
    }

    if (channel.id !== player.voiceChannelId) {
      return message.reply("You must be in the same voice channel as the bot!");
    }

    const isAutoplay = player.autoPlay;
    player.setAutoPlay(!isAutoplay);

    return message.reply(`Autoplay is now **${!isAutoplay ? "enabled" : "disabled"}**.`);
  },
};
```

## Full commands folder snapshot

Once you create all the files from this page, your `commands/` folder should look like this:

```txt
commands/
‚îú‚îÄ autoplay.js
‚îú‚îÄ filter.js
‚îú‚îÄ join.js
‚îú‚îÄ nowplaying.js
‚îú‚îÄ pause.js
‚îú‚îÄ play.js
‚îú‚îÄ queue.js
‚îú‚îÄ resume.js
‚îú‚îÄ seek.js
‚îú‚îÄ skip.js
‚îú‚îÄ stop.js
‚îî‚îÄ volume.js
```

::alert{type="success" icon="lucide:lightbulb"}
From here, you can add slash commands, permissions, cooldowns, or a more advanced command framework ‚Äî but this foundation is already ‚Äúreal bot‚Äù ready.
::
