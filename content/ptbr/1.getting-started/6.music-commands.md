---
title: Comandos de Música
description: "Aprenda a criar comandos de música avançados com o Moonlink.js"
icon: 'lucide:command'
authors:
  - avatar: https://www.npmjs.com/npm-avatar/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdmF0YXJVUkwiOiJodHRwczovL3MuZ3JhdmF0YXIuY29tL2F2YXRhci9hNmE5NDVhYjJiNzk1MjcyNzVjN2IwMWEyNWM1YzQ2NT9zaXplPTQ5NiZkZWZhdWx0PXJldHJvIn0.5hP6oyShhR-UWUi6KF-lA0cWmE_BJjvIFAwkYCGEZNo
    name: Lucas Morais Rodrigues
    username: 1Lucas1apk
    to: https://github.com/1Lucas1apk
    target: _blank
---

::alert{type="info" icon="lucide:command"}
Este guia abrangente mostrará como criar comandos de música avançados para o seu bot do Discord usando o Moonlink.js. Você aprenderá a implementar recursos como controle de volume, busca em faixas, filtros de áudio e muito mais, com detalhamentos de cada componente do código.
::

## Introdução

Na seção anterior, criamos um bot de música básico com comandos essenciais. Agora, vamos expandir a funcionalidade do nosso bot adicionando comandos de música mais avançados que melhorarão significativamente a experiência do usuário:

- **Controle de Volume**: Ajuste fino do volume de reprodução
- **Busca na Faixa**: Pule para momentos específicos em uma faixa
- **Filtros de Áudio**: Aplique efeitos como bassboost, nightcore e mais
- **Informações de "Tocando Agora"**: Veja informações detalhadas da faixa
- **Modos de Loop**: Repita faixas ou a fila inteira
- **Embaralhar Fila**: Randomize a ordem de reprodução

## Pré-requisitos

Antes de começarmos, garanta que você tenha:

1. Concluído a seção "Criando um Bot de Música"
2. Um bot de música funcional com comandos básicos
3. Compreensão dos conceitos básicos do Moonlink.js e Discord.js
4. Node.js e as dependências necessárias instaladas

## Visão Geral da Estrutura de Comandos

Cada comando que criamos segue uma estrutura consistente e robusta:

```js
// Estrutura básica de comando
module.exports = {
  name: 'nomecomando',
  aliases: ['cmd', 'cm'], // Nomes alternativos opcionais
  description: 'Descrição do comando',
  execute(message, args, client) {
    // Verificações de segurança
    // Lógica do comando
    // Feedback ao usuário
  }
};
```

Vamos detalhar as verificações de segurança essenciais que todo comando deve incluir:

```js
// Verificação de existência do player
const player = client.manager.players.get(message.guild.id);
if (!player) {
  return message.reply('Nenhum player ativo!');
}

// Verificação de canal de voz
if (!message.member.voice.channel) {
  return message.reply('Entre em um canal de voz primeiro!');
}

// Verificação do mesmo canal
if (message.member.voice.channel?.id !== player.voiceChannelId) {
  return message.reply('Você precisa estar no mesmo canal de voz!');
}
```

## Comando de Volume

O comando de volume permite que os usuários ajustem o volume da reprodução. Vamos detalhá-lo:

```js
// 1. Estrutura do comando e validação inicial
module.exports = {
  name: 'volume',
  aliases: ['vol', 'v'],
  description: 'Ajusta o volume do player',
  execute(message, args, client) {
    // Validação do player
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    // Validação do canal de voz
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz!');
    }
```

Esta primeira parte configura a estrutura do comando e realiza as validações iniciais.

```js
    // 2. Verificação do volume atual
    if (!args.length) {
      return message.reply(`O volume atual é: **${player.volume}%**`);
    }
    
    // 3. Analisar e validar a entrada de volume
    const volume = parseInt(args[0]);
    if (isNaN(volume)) {
      return message.reply('Por favor, forneça um número válido!');
    }
```

Esta seção lida com a verificação do volume atual quando nenhum argumento é fornecido e analisa a entrada de volume.

```js
    // 4. Validação de intervalo e aplicação do volume
    if (volume < 0 || volume > 1000) {
      return message.reply('O volume deve ser entre 0 e 1000!');
    }
    
    player.setVolume(volume);
    message.reply(`Volume definido para: **${volume}%**`);
  },
};
```

A parte final valida o intervalo de volume e aplica a alteração.

Comando de Volume Completo:
```js
module.exports = {
  name: 'volume',
  aliases: ['vol', 'v'],
  description: 'Ajusta o volume do player',
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz!');
    }
    
    if (!args.length) {
      return message.reply(`O volume atual é: **${player.volume}%**`);
    }
    
    const volume = parseInt(args[0]);
    if (isNaN(volume)) {
      return message.reply('Por favor, forneça um número válido!');
    }
    
    if (volume < 0 || volume > 1000) {
      return message.reply('O volume deve ser entre 0 e 1000!');
    }
    
    player.setVolume(volume);
    message.reply(`Volume definido para: **${volume}%**`);
  },
};
```

## Comando Seek

O comando `seek` permite a navegação precisa dentro das faixas. Vamos examinar cada parte:

```js
// 1. Configuração do comando e validações iniciais
module.exports = {
  name: 'seek',
  aliases: ['jump', 'goto'],
  description: 'Busca uma posição específica na faixa atual',
  execute(message, args, client) {
    // Validação do player e da faixa
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz!');
    }
    
    if (!player.current) {
      return message.reply('Nada está tocando!');
    }
    
    // Verificação se a faixa é "seekable"
    if (!player.current.isSeekable) {
      return message.reply('Esta faixa não pode ser buscada!');
    }
```

Esta seção estabelece o comando e realiza as validações iniciais.

```js
    // 2. Lógica de análise de tempo
    if (!args.length) {
      return message.reply('Forneça uma posição (ex: 1:30 ou 90)');
    }
    
    const position = args[0];
    let milliseconds = 0;
    
    // Lida com diferentes formatos de tempo
    if (position.includes(':')) {
      // Formato: minutos:segundos
      const [minutes, seconds] = position.split(':');
      milliseconds = (parseInt(minutes) * 60 + parseInt(seconds)) * 1000;
    } else {
      // Formato: apenas segundos
      milliseconds = parseInt(position) * 1000;
    }
```

Esta parte lida com a análise de diferentes formatos de tempo.

```js
    // 3. Validação final e busca
    if (isNaN(milliseconds)) {
      return message.reply('Formato de tempo inválido!');
    }
    
    if (milliseconds > player.current.duration) {
      return message.reply(`A faixa tem apenas ${formatDuration(player.current.duration)} de duração!`);
    }
    
    player.seek(milliseconds);
    message.reply(`Buscado para: **${formatDuration(milliseconds)}**`);
  },
};

// Função auxiliar para formatação de tempo
function formatDuration(ms) {
  const seconds = Math.floor((ms / 1000) % 60);
  const minutes = Math.floor((ms / (1000 * 60)) % 60);
  const hours = Math.floor(ms / (1000 * 60 * 60));
  
  return `${hours ? `${hours}:` : ''}${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}
```

A parte final valida o tempo analisado e realiza a operação de busca.

Comando Seek Completo:
```js
module.exports = {
  name: 'seek',
  aliases: ['jump', 'goto'],
  description: 'Busca uma posição específica na faixa atual',
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz!');
    }
    
    if (!player.current) {
      return message.reply('Nada está tocando!');
    }
    
    if (!player.current.isSeekable) {
      return message.reply('Esta faixa não pode ser buscada!');
    }
    
    if (!args.length) {
      return message.reply('Forneça uma posição (ex: 1:30 ou 90)');
    }
    
    const position = args[0];
    let milliseconds = 0;
    
    if (position.includes(':')) {
      const [minutes, seconds] = position.split(':');
      milliseconds = (parseInt(minutes) * 60 + parseInt(seconds)) * 1000;
    } else {
      milliseconds = parseInt(position) * 1000;
    }
    
    if (isNaN(milliseconds)) {
      return message.reply('Formato de tempo inválido!');
    }
    
    if (milliseconds > player.current.duration) {
      return message.reply(`A faixa tem apenas ${formatDuration(player.current.duration)} de duração!`);
    }
    
    player.seek(milliseconds);
    message.reply(`Buscado para: **${formatDuration(milliseconds)}**`);
  },
};

function formatDuration(ms) {
  const seconds = Math.floor((ms / 1000) % 60);
  const minutes = Math.floor((ms / (1000 * 60)) % 60);
  const hours = Math.floor(ms / (1000 * 60 * 60));
  
  return `${hours ? `${hours}:` : ''}${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}
```

## Comando Now Playing

O comando `Now Playing` fornece informações detalhadas sobre a faixa atualmente em reprodução. Vamos detalhá-lo:

```js
// 1. Configuração inicial e importações
const { EmbedBuilder } = require('discord.js');

module.exports = {
  name: 'nowplaying',
  aliases: ['np', 'current'],
  description: 'Mostra informações sobre a faixa atual',
  execute(message, args, client) {
    // Validação do player e da faixa
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    if (!player.current) {
      return message.reply('Nada está tocando!');
    }
```

Esta parte configura o comando e realiza as validações iniciais.

```js
    // 2. Funções auxiliares para formatação
    const track = player.current;
    
    const formatDuration = (ms) => {
      const seconds = Math.floor((ms / 1000) % 60);
      const minutes = Math.floor((ms / (1000 * 60)) % 60);
      const hours = Math.floor(ms / (1000 * 60 * 60));
      
      return `${hours ? `${hours}:` : ''}${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    };
    
    const createProgressBar = (current, total, length = 15) => {
      const progress = Math.round((current / total) * length);
      return '▬'.repeat(progress) + '🔘' + '▬'.repeat(length - progress);
    };
```

Esta seção define funções auxiliares para formatação de tempo e criação de barra de progresso.

```js
    // 3. Crie e envie um embed rico
    const embed = new EmbedBuilder()
      .setTitle('Tocando Agora')
      .setColor('#0099ff')
      .setDescription(`[${track.title}](${track.uri})`)
      .addFields(
        { name: 'Autor', value: track.author, inline: true },
        { name: 'Pedido Por', value: `<@${track.requesterBy.id}>`, inline: true },
        { name: 'Duração', value: ``${formatDuration(track.position)} / ${formatDuration(track.duration)}`\n${createProgressBar(player.position, track.duration)}`, inline: false }
      );
    
    if (track.thumbnail) {
      embed.setThumbnail(track.thumbnail);
    }
    
    message.reply({ embeds: [embed] });
  },
};
```

A parte final cria e envia um embed rico com informações da faixa.

Comando Now Playing Completo:
```js
const { EmbedBuilder } = require('discord.js');

module.exports = {
  name: 'nowplaying',
  aliases: ['np', 'current'],
  description: 'Mostra informações sobre a faixa atual',
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }

    if (!player.current) {
      return message.reply('Nada está tocando!');
    }

    const track = player.current;

    const formatDuration = (ms) => {
      const seconds = Math.floor((ms / 1000) % 60);
      const minutes = Math.floor((ms / (1000 * 60)) % 60);
      const hours = Math.floor(ms / (1000 * 60 * 60));

      return `${hours ? `${hours}:` : ''}${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    };

    const createProgressBar = (current, total, length = 15) => {
      const progress = Math.round((current / total) * length);
      return '▬'.repeat(progress) + '🔘' + '▬'.repeat(length - progress);
    };

    const embed = new EmbedBuilder()
      .setTitle('Tocando Agora')
      .setColor('#0099ff')
      .setDescription(`[${track.title}](${track.url})`)
      .addFields(
        { name: 'Autor', value: track.author, inline: true },
        { name: 'Pedido Por', value: `<@${track.requestedBy.id}>`, inline: true },
        { name: 'Duração', value: ``${formatDuration(track.position)} / ${formatDuration(track.duration)}`\n${createProgressBar(track.position, track.duration)}`, inline: false }
      );

    if (track.artworkUrl) {
      embed.setThumbnail(track.artworkUrl);
    }

    message.reply({ embeds: [embed] });
  },
};
```

## Comando Loop

O comando `Loop` ativa diferentes modos de repetição para a reprodução. Vamos examinar cada parte:

```js
// 1. Configuração do comando e validações iniciais
module.exports = {
  name: 'loop',
  aliases: ['repeat', 'l'],
  description: 'Define o modo de loop',
  execute(message, args, client) {
    // Validação do player
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    // Validação do canal de voz
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz!');
    }
```

Esta parte configura o comando e realiza as validações iniciais.

```js
    // 2. Alternar modo se não houver argumentos
    if (!args.length) {
      if (player.loop === 'none') {
        player.setLoop('track');
        return message.reply('Loop de faixa ativado.');
      } else {
        player.setLoop('none');
        return message.reply('Loop desativado.');
      }
    }
```

Esta seção lida com a alternância do modo de loop quando nenhum argumento é fornecido.

```js
    // 3. Analisar e aplicar o modo de loop solicitado
    const mode = args[0].toLowerCase();
    
    switch (mode) {
      case 'none':
      case 'off':
      case 'disable':
        player.setLoop('none');
        message.reply('Loop desativado.');
        break;
        
      case 'track':
      case 'song':
      case 'current':
        player.setLoop('track');
        message.reply('Loop de faixa ativado.');
        break;
        
      case 'queue':
      case 'all':
        player.setLoop('queue');
        message.reply('Loop de fila ativado.');
        break;
        
      default:
        message.reply('Modo inválido! Use: `none`, `track`, ou `queue`.');
        break;
    }
  },
};
```

A parte final analisa e aplica o modo de loop solicitado.

Comando Loop Completo:
```js
module.exports = {
  name: 'loop',
  aliases: ['repeat', 'l'],
  description: 'Define o modo de loop',
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz!');
    }
    
    if (!args.length) {
      if (player.loop === 'none') {
        player.setLoop('track');
        return message.reply('Loop de faixa ativado.');
      } else {
        player.setLoop('none');
        return message.reply('Loop desativado.');
      }
    }
    
    const mode = args[0].toLowerCase();
    
    switch (mode) {
      case 'none':
      case 'off':
      case 'disable':
        player.setLoop('none');
        message.reply('Loop desativado.');
        break;
        
      case 'track':
      case 'song':
      case 'current':
        player.setLoop('track');
        message.reply('Loop de faixa ativado.');
        break;
        
      case 'queue':
      case 'all':
        player.setLoop('queue');
        message.reply('Loop de fila ativado.');
        break;
        
      default:
        message.reply('Modo inválido! Use: `none`, `track`, ou `queue`.');
        break;
    }
  },
};
```

## Comando Filter

O comando `Filter` aplica efeitos de áudio à reprodução. Vamos detalhá-lo:

```js
// 1. Configuração do comando e validações iniciais
module.exports = {
  name: 'filter',
  aliases: ['effect', 'fx'],
  description: 'Aplica um filtro de áudio',
  execute(message, args, client) {
    // Validação do player
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    // Validação do canal de voz
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz!');
    }
```

Esta parte configura o comando e realiza as validações iniciais.

```js
    // 2. Mostrar filtros disponíveis se não houver argumentos
    if (!args.length) {
      return message.reply('Filtros disponíveis: `reset`, `bassboost`, `nightcore`, `vaporwave`, `8d`, `tremolo`, `vibrato`, `karaoke`');
    }
    
    // 3. Obter e aplicar o filtro solicitado
    const filter = args[0].toLowerCase();
```

Esta seção lida com a exibição de filtros disponíveis e a obtenção do filtro solicitado.

```js
    // 4. Aplicar efeitos de filtro
    switch (filter) {
      case 'reset':
        // Remove todos os filtros
        player.filters.resetFilters();
        message.reply('Todos os filtros foram resetados.');
        break;
        
      case 'bassboost':
        // Melhora as baixas frequências
        player.filters.setEqualizer([
          { band: 0, gain: 0.6 }, // 25 Hz
          { band: 1, gain: 0.7 }, // 40 Hz
          { band: 2, gain: 0.8 }, // 63 Hz
          { band: 3, gain: 0.55 }, // 100 Hz
          { band: 4, gain: 0.25 }, // 160 Hz
        ]);
        message.reply('Filtro bassboost aplicado.');
        break;
        
      case 'nightcore':
        // Aumenta a velocidade e o tom
        player.filters.setTimescale({
          speed: 1.2, // 20% mais rápido
          pitch: 1.2, // 20% mais agudo
          rate: 1.0 // Taxa normal
        });
        message.reply('Filtro nightcore aplicado.');
        break;
        
      case 'vaporwave':
        // Diminui a velocidade e o tom
        player.filters.setTimescale({
          speed: 0.8, // 20% mais lento
          pitch: 0.8, // 20% mais grave
          rate: 1.0 // Taxa normal
        });
        message.reply('Filtro vaporwave aplicado.');
        break;
        
      case '8d':
        // Efeito de áudio rotativo
        player.filters.setRotation({
          rotationHz: 0.2 // Velocidade de rotação
        });
        message.reply('Filtro 8D aplicado.');
        break;
        
      case 'tremolo':
        // Variação de amplitude
        player.filters.setTremolo({
          frequency: 4.0, // Velocidade da variação
          depth: 0.75 // Intensidade do efeito
        });
        message.reply('Filtro tremolo aplicado.');
        break;
        
      case 'vibrato':
        // Variação de frequência
        player.filters.setVibrato({
          frequency: 4.0, // Velocidade da variação
          depth: 0.75 // Intensidade do efeito
        });
        message.reply('Filtro vibrato aplicado.');
        break;
        
      case 'karaoke':
        // Tentativa de remoção de vocais
        player.filters.setKaraoke({
          level: 1.0, // Nível do efeito
          monoLevel: 1.0, // Nível do canal mono
          filterBand: 220.0, // Banda de frequência
          filterWidth: 100.0 // Largura do efeito
        });
        message.reply('Filtro karaokê aplicado.');
        break;
        
      default:
        message.reply('Filtro inválido! Filtros disponíveis: `reset`, `bassboost`, `nightcore`, `vaporwave`, `8d`, `tremolo`, `vibrato`, `karaoke`');
        break;
    }
  },
};
```

A parte final aplica o efeito de filtro selecionado.

Comando Filter Completo:
```js
module.exports = {
  name: 'filter',
  aliases: ['effect', 'fx'],
  description: 'Aplica um filtro de áudio',
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz!');
    }
    
    if (!args.length) {
      return message.reply('Filtros disponíveis: `reset`, `bassboost`, `nightcore`, `vaporwave`, `8d`, `tremolo`, `vibrato`, `karaoke`');
    }
    
    const filter = args[0].toLowerCase();
    
    switch (filter) {
      case 'reset':
        player.filters.resetFilters();
        message.reply('Todos os filtros foram resetados.');
        break;
        
      case 'bassboost':
        player.filters.setEqualizer([
          { band: 0, gain: 0.6 }, // 25 Hz
          { band: 1, gain: 0.7 }, // 40 Hz
          { band: 2, gain: 0.8 }, // 63 Hz
          { band: 3, gain: 0.55 }, // 100 Hz
          { band: 4, gain: 0.25 }, // 160 Hz
        ]);
        message.reply('Filtro bassboost aplicado.');
        break;
        
      case 'nightcore':
        player.filters.setTimescale({
          speed: 1.2, // 20% mais rápido
          pitch: 1.2, // 20% mais agudo
          rate: 1.0 // Taxa normal
        });
        message.reply('Filtro nightcore aplicado.');
        break;
        
      case 'vaporwave':
        player.filters.setTimescale({
          speed: 0.8, // 20% mais lento
          pitch: 0.8, // 20% mais grave
          rate: 1.0 // Taxa normal
        });
        message.reply('Filtro vaporwave aplicado.');
        break;
        
      case '8d':
        player.filters.setRotation({
          rotationHz: 0.2 // Velocidade de rotação
        });
        message.reply('Filtro 8D aplicado.');
        break;
        
      case 'tremolo':
        player.filters.setTremolo({
          frequency: 4.0, // Velocidade da variação
          depth: 0.75 // Intensidade do efeito
        });
        message.reply('Filtro tremolo aplicado.');
        break;
        
      case 'vibrato':
        player.filters.setVibrato({
          frequency: 4.0, // Velocidade da variação
          depth: 0.75 // Intensidade do efeito
        });
        message.reply('Filtro vibrato aplicado.');
        break;
        
      case 'karaoke':
        player.filters.setKaraoke({
          level: 1.0, // Nível do efeito
          monoLevel: 1.0, // Nível do canal mono
          filterBand: 220.0, // Banda de frequência
          filterWidth: 100.0 // Largura do efeito
        });
        message.reply('Filtro karaokê aplicado.');
        break;
        
      default:
        message.reply('Filtro inválido! Filtros disponíveis: `reset`, `bassboost`, `nightcore`, `vaporwave`, `8d`, `tremolo`, `vibrato`, `karaoke`');
        break;
    }
  },
};
```

## Comando Shuffle

O comando `Shuffle` randomiza a ordem das faixas na fila. Vamos detalhá-lo:

```js
// 1. Configuração do comando e validações iniciais
module.exports = {
  name: 'shuffle',
  aliases: ['mix', 'randomize'],
  description: 'Embaralha a fila',
  execute(message, args, client) {
    // Validação do player
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    // Validação do canal de voz
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz!');
    }
```

Esta parte configura o comando e realiza as validações iniciais.

```js
    // 2. Validação da fila e embaralhamento
    if (!player.queue.length) {
      return message.reply('A fila está vazia!');
    }
    
    player.queue.shuffle();
    
    // 3. Feedback ao usuário
    message.reply('🔀 Fila embaralhada!');
  },
};
```

A parte final valida a fila e realiza a operação de embaralhamento.

Comando Shuffle Completo:
```js
module.exports = {
  name: 'shuffle',
  aliases: ['mix', 'randomize'],
  description: 'Embaralha a fila',
  execute(message, args, client) {
    const player = client.manager.players.get(message.guild.id);
    if (!player) {
      return message.reply('Nenhum player ativo!');
    }
    
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz!');
    }
    
    if (!player.queue.length) {
      return message.reply('A fila está vazia!');
    }
    
    player.queue.shuffle();
    message.reply('🔀 Fila embaralhada!');
  },
};
```