---
title: Lyrics
description: "API reference for the Lyrics class in Moonlink.js"
icon: lucide:file-text
authors:
  - avatar: https://www.npmjs.com/npm-avatar/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdmF0YXJVUkwiOiJodHRwczovL3MuZ3JhdmF2YXRhci5jb20vYXZhdGFyL2E2YTk0NWFhYjJiNzk1MjcyNzVjN2IwMWEyNWM1YzQ2NT9zaXplPTQ5NiZkZWZhdWx0PXJldHJvIn0.5hP6oyShhR-UWUi6KF-lA0cWmE_BJjvIFAwkYCGEZNo
    name: Lucas Morais Rodrigues
    username: 1Lucas1apk
    to: https://github.com/1Lucas1apk
    target: _blank
---

<branch version="1.0.x">

::card{icon="lucide:file-text"}
#title
Lyrics Class

#description
The Lyrics class provides functionality to fetch and display lyrics for currently playing tracks in Moonlink.js.
<br>
```js
player.lyrics.getLyrics()
```
::

::alert{type="info" icon="lucide:info"}
The lyrics functionality requires a NodeLink server. Standard Lavalink servers do not support this feature.
::

## Overview

::card{icon="lucide:box"}
#title
Properties

#description
Core properties of the Lyrics class.
<br>
<h5>Available Properties</h5>

#content
| Property | Type | Description |
|----------|------|-------------|
| `player` | `Player` | Reference to the player instance that owns this lyrics handler |
::

## Methods

::card{icon="lucide:settings"}
#title
Methods

#description
Methods available in the Lyrics class.
<br>
<h5>Available Methods</h5>

#content
#### getLyrics
::field{name="getLyrics" type="method"}
::stack
  ::card
  ---
  icon: 'lucide:search'
  ---
  #title
  Get Lyrics

  #description
  Fetches lyrics for the currently playing track.
  <br>
  <h5>Parameters</h5>

  ::field-group
    This method takes no parameters.
  ::
  ::

  ::card
  ---
  icon: 'lucide:fold-horizontal'
  icon-size: 26
  horizontal: true
  ---
  #title
  Returns & Example

  #description
  **Returns**
  â€¢ **`Promise<IRESTGetLyrics | null>`** - Lyrics data or null if no track is playing or NodeLink is not available

```js
// Basic usage
const lyrics = await player.lyrics.getLyrics();

if (lyrics && lyrics.loadType === 'track') {
  console.log(`Song: ${lyrics.data.name}`);
  console.log(`Synchronized: ${lyrics.data.synced}`);
  
  for (const line of lyrics.data.data) {
    console.log(`[${formatTime(line.startTime)}] ${line.text}`);
  }
}
```
  ::
::
::

## Response Structure

::card{icon="lucide:file-json"}
#title
Lyrics Response Structure

#description
The structure of the lyrics response object.

#content
```typescript
interface IRESTGetLyrics {
  loadType: string;        // 'track' if lyrics found
  data: {
    name: string;         // Song name
    synced: boolean;      // Whether lyrics are time-synchronized
    data: Array<{
      startTime: number;  // Start time in milliseconds
      endTime: number;    // End time in milliseconds
      text: string;      // Lyrics line text
    }>;
    rtl: boolean;        // Right-to-left text direction
  };
}
```
::

## Usage Examples

::card{icon="lucide:code"}
#title
Advanced Usage Examples

#description
Comprehensive examples of implementing lyrics functionality.

#content
### Discord Bot with Lyrics Display

```js
async function displayLyrics(message) {
  const player = manager.players.get(message.guild.id);
  
  if (!player?.playing) {
    return message.channel.send('âš ï¸ No track is currently playing!');
  }
  
  const loadingMsg = await message.channel.send('ðŸ” Fetching lyrics...');
  
  try {
    const lyrics = await player.lyrics.getLyrics();
    
    if (!lyrics || lyrics.loadType !== 'track') {
      return loadingMsg.edit('âŒ No lyrics found for this track.');
    }
    
    const { name, synced, data } = lyrics.data;
    const currentTrack = player.current;
    
    // Create embeds for paginated lyrics display
    const embeds = [];
    let currentPage = '';
    let lineCount = 0;
    
    for (const line of data) {
      const timestamp = synced ? `\[${formatTimestamp(line.startTime)}\]` : '';
      const lineText = `${timestamp}${line.text}\n`;
      
      if ((currentPage + lineText).length > 4000 || lineCount >= 15) {
        embeds.push({
          title: `ðŸ“ Lyrics for ${currentTrack.title}`,
          description: currentPage,
          color: 0x3498db,
          footer: {
            text: `${synced ? 'Synchronized' : 'Unsynchronized'} lyrics | Page ${embeds.length + 1}`
          }
        });
        currentPage = lineText;
        lineCount = 1;
      } else {
        currentPage += lineText;
        lineCount++;
      }
    }
    
    // Add the last page if there's remaining content
    if (currentPage.length > 0) {
      embeds.push({
        title: `ðŸ“ Lyrics for ${currentTrack.title}`,
        description: currentPage,
        color: 0x3498db,
        footer: {
          text: `${synced ? 'Synchronized' : 'Unsynchronized'} lyrics | Page ${embeds.length + 1}`
        }
      });
    }
    
    // Setup pagination buttons
    const row = new Discord.ActionRowBuilder()
      .addComponents(
        new Discord.ButtonBuilder()
          .setCustomId('prev')
          .setLabel('Previous')
          .setStyle('Primary')
          .setEmoji('â¬…ï¸'),
        new Discord.ButtonBuilder()
          .setCustomId('next')
          .setLabel('Next')
          .setStyle('Primary')
          .setEmoji('âž¡ï¸')
      );
    
    let currentIndex = 0;
    const initialMessage = await loadingMsg.edit({
      content: null,
      embeds: [embeds[0]],
      components: [row]
    });
    
    // Handle pagination
    const collector = initialMessage.createMessageComponentCollector({
      time: 300000 // 5 minutes
    });
    
    collector.on('collect', async (interaction) => {
      if (interaction.customId === 'prev') {
        currentIndex = Math.max(0, currentIndex - 1);
      } else if (interaction.customId === 'next') {
        currentIndex = Math.min(embeds.length - 1, currentIndex + 1);
      }
      
      await interaction.update({
        embeds: [embeds[currentIndex]],
        components: [row]
      });
    });
    
    collector.on('end', () => {
      initialMessage.edit({ components: [] });
    });
  } catch (error) {
    console.error('Error fetching lyrics:', error);
    loadingMsg.edit('âŒ An error occurred while fetching lyrics.');
  }
}

// Helper function to format timestamps
function formatTimestamp(ms) {
  const minutes = Math.floor(ms / 60000);
  const seconds = ((ms % 60000) / 1000).toFixed(0);
  return `${minutes}:${seconds.padStart(2, '0')}`;
}

// Command handler
client.on('messageCreate', async (message) => {
  if (message.content === '!lyrics') {
    await displayLyrics(message);
  }
});
```

### Real-time Lyrics Display

```js
class LyricsDisplay {
  constructor(player) {
    this.player = player;
    this.lyrics = null;
    this.currentLineIndex = 0;
    this.displayInterval = null;
  }
  
  async start() {
    try {
      this.lyrics = await this.player.lyrics.getLyrics();
      
      if (!this.lyrics?.data?.synced) {
        console.log('âŒ No synchronized lyrics available');
        return;
      }
      
      this.displayInterval = setInterval(() => {
        this.updateDisplay();
      }, 100);
      
      // Stop display when track ends
      this.player.once('trackEnd', () => this.stop());
    } catch (error) {
      console.error('Error starting lyrics display:', error);
    }
  }
  
  updateDisplay() {
    if (!this.lyrics || !this.player.playing) return;
    
    const currentTime = this.player.position;
    const lines = this.lyrics.data.data;
    
    // Find current line based on timestamp
    const newLineIndex = lines.findIndex((line, index) => {
      return currentTime >= line.startTime && 
             (index === lines.length - 1 || currentTime < lines[index + 1].startTime);
    });
    
    if (newLineIndex !== -1 && newLineIndex !== this.currentLineIndex) {
      this.currentLineIndex = newLineIndex;
      
      // Display current line and next line
      console.clear();
      console.log('ðŸŽµ Now Playing:', this.player.current.title);
      console.log('\nCurrent Line:');
      console.log(lines[this.currentLineIndex].text);
      
      if (lines[this.currentLineIndex + 1]) {
        console.log('\nNext Line:');
        console.log(lines[this.currentLineIndex + 1].text);
      }
    }
  }
  
  stop() {
    if (this.displayInterval) {
      clearInterval(this.displayInterval);
      this.displayInterval = null;
    }
    this.lyrics = null;
    this.currentLineIndex = 0;
  }
}

// Usage
player.on('trackStart', async () => {
  const lyricsDisplay = new LyricsDisplay(player);
  await lyricsDisplay.start();
});
```
::

## Lyrics

::button-link{right-icon="lucide:arrow-right" to="/api/database"}
  Continue to Database
:: 
