---
title: Lyrics
description: "Refer√™ncia da API para a classe Lyrics em Moonlink.js"
icon: lucide:file-text
authors:
  - avatar: https://www.npmjs.com/npm-avatar/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdmF0YXJVUkwiOiJodHRwczovL3MuZ3JhdmF2YXRhci5jb20vYXZhdGFyL2E2YTk0NWFhYjJiNzk1MjcyNzVjN2IwMWEyNWM1YzQ2NT9zaXplPTQ5NiZkZWZhdWx0PXJldHJvIn0.5hP6oyShhR-UWUi6KF-lA0cWmE_BJjvIFAwkYCGEZNo
    name: Lucas Morais Rodrigues
    username: 1Lucas1apk
    to: https://github.com/1Lucas1apk
    target: _blank
---

<branch version="1.0.x">

::card{icon="lucide:file-text"}
#title
Classe Lyrics

#description
A classe Lyrics fornece funcionalidade para buscar e exibir letras de faixas atualmente em reprodu√ß√£o no Moonlink.js.
<br>
```js
player.lyrics.getLyrics()
```
::

::alert{type="info" icon="lucide:info"}
A funcionalidade de letras requer um servidor NodeLink. Servidores Lavalink padr√£o n√£o suportam este recurso.
::

## Vis√£o Geral

::card{icon="lucide:box"}
#title
Propriedades

#description
Propriedades principais da classe Lyrics.
<br>
<h5>Propriedades Dispon√≠veis</h5>

#content
| Propriedade | Tipo | Descri√ß√£o |
|----------|------|-------------|
| `player` | `Player` | Refer√™ncia √† inst√¢ncia do player que possui este manipulador de letras |
::

## M√©todos

::card{icon="lucide:settings"}
#title
M√©todos

#description
M√©todos dispon√≠veis na classe Lyrics.
<br>
<h5>M√©todos Dispon√≠veis</h5>

#content
#### getLyrics
::field{name="getLyrics" type="method"}
::stack
  ::card
  ---
  icon: 'lucide:search'
  ---
  #title
  Obter Letras

  #description
  Busca letras para a faixa atualmente em reprodu√ß√£o.
  <br>
  <h5>Par√¢metros</h5>

  ::field-group
    Este m√©todo n√£o aceita par√¢metros.
  ::
  ::

  ::card
  ---
  icon: 'lucide:fold-horizontal'
  icon-size: 26
  horizontal: true
  ---
  #title
  Retornos e Exemplo

  #description
  **Retornos**
  ‚Ä¢ **`Promise<IRESTGetLyrics | null>`** - Dados das letras ou nulo se nenhuma faixa estiver tocando ou NodeLink n√£o estiver dispon√≠vel

```js
// Uso b√°sico
const lyrics = await player.lyrics.getLyrics();

if (lyrics && lyrics.loadType === 'track') {
  console.log(`M√∫sica: ${lyrics.data.name}`);
  console.log(`Sincronizado: ${lyrics.data.synced}`);
  
  for (const line of lyrics.data.data) {
    console.log(`[${formatTime(line.startTime)}] ${line.text}`);
  }
}
```
  ::
::
::

## Estrutura da Resposta

::card{icon="lucide:file-json"}
#title
Estrutura da Resposta das Letras

#description
A estrutura do objeto de resposta das letras.

#content
```typescript
interface IRESTGetLyrics {
  loadType: string;        // 'track' se as letras forem encontradas
  data: {
    name: string;         // Nome da m√∫sica
    synced: boolean;      // Se as letras s√£o sincronizadas por tempo
    data: Array<{
      startTime: number;  // Tempo de in√≠cio em milissegundos
      endTime: number;    // Tempo de fim em milissegundos
      text: string;      // Texto da linha da letra
    }>;
    rtl: boolean;        // Dire√ß√£o do texto da direita para a esquerda
  };
}
```
::

## Exemplos de Uso

::card{icon="lucide:code"}
#title
Exemplos de Uso Avan√ßado

#description
Exemplos abrangentes de implementa√ß√£o da funcionalidade de letras.

#content
### Bot Discord com Exibi√ß√£o de Letras

```js
async function displayLyrics(message) {
  const player = manager.players.get(message.guild.id);
  
  if (!player?.playing) {
    return message.channel.send('‚ö†Ô∏è Nenhuma faixa est√° tocando no momento!');
  }
  
  const loadingMsg = await message.channel.send('üîç Buscando letras...');
  
  try {
    const lyrics = await player.lyrics.getLyrics();
    
    if (!lyrics || lyrics.loadType !== 'track') {
      return loadingMsg.edit('‚ùå Nenhuma letra encontrada para esta faixa.');
    }
    
    const { name, synced, data } = lyrics.data;
    const currentTrack = player.current;
    
    // Crie embeds para exibi√ß√£o de letras paginadas
    const embeds = [];
    let currentPage = '';
    let lineCount = 0;
    
    for (const line of data) {
      const timestamp = synced ? `\[${formatTimestamp(line.startTime)}\]` : '';
      const lineText = `${timestamp}${line.text}\n`;
      
      if ((currentPage + lineText).length > 4000 || lineCount >= 15) {
        embeds.push({
          title: `üìù Letras para ${currentTrack.title}`,
          description: currentPage,
          color: 0x3498db,
          footer: {
            text: `${synced ? 'Sincronizadas' : 'N√£o sincronizadas'} letras | P√°gina ${embeds.length + 1}`
          }
        });
        currentPage = lineText;
        lineCount = 1;
      } else {
        currentPage += lineText;
        lineCount++;
      }
    }
    
    // Adicione a √∫ltima p√°gina se houver conte√∫do restante
    if (currentPage.length > 0) {
      embeds.push({
        title: `üìù Letras para ${currentTrack.title}`,
        description: currentPage,
        color: 0x3498db,
        footer: {
          text: `${synced ? 'Sincronizadas' : 'N√£o sincronizadas'} letras | P√°gina ${embeds.length + 1}`
        }
      });
    }
    
    // Configurar bot√µes de pagina√ß√£o
    const row = new Discord.ActionRowBuilder()
      .addComponents(
        new Discord.ButtonBuilder()
          .setCustomId('prev')
          .setLabel('Anterior')
          .setStyle('Primary')
          .setEmoji('‚¨ÖÔ∏è'),
        new Discord.ButtonBuilder()
          .setCustomId('next')
          .setLabel('Pr√≥ximo')
          .setStyle('Primary')
          .setEmoji('‚û°Ô∏è')
      );
    
    let currentIndex = 0;
    const initialMessage = await loadingMsg.edit({
      content: null,
      embeds: [embeds[0]],
      components: [row]
    });
    
    // Lidar com a pagina√ß√£o
    const collector = initialMessage.createMessageComponentCollector({
      time: 300000 // 5 minutos
    });
    
    collector.on('collect', async (interaction) => {
      if (interaction.customId === 'prev') {
        currentIndex = Math.max(0, currentIndex - 1);
      } else if (interaction.customId === 'next') {
        currentIndex = Math.min(embeds.length - 1, currentIndex + 1);
      }
      
      await interaction.update({
        embeds: [embeds[currentIndex]],
        components: [row]
      });
    });
    
    collector.on('end', () => {
      initialMessage.edit({ components: [] });
    });
  } catch (error) {
    console.error('Erro ao buscar letras:', error);
    loadingMsg.edit('‚ùå Ocorreu um erro ao buscar letras.');
  }
}

// Fun√ß√£o auxiliar para formatar timestamps
function formatTimestamp(ms) {
  const minutes = Math.floor(ms / 60000);
  const seconds = ((ms % 60000) / 1000).toFixed(0);
  return `${minutes}:${seconds.padStart(2, '0')}`;
}

// Manipulador de comando
client.on('messageCreate', async (message) => {
  if (message.content === '!lyrics') {
    await displayLyrics(message);
  }
});
```

### Exibi√ß√£o de Letras em Tempo Real

```js
class LyricsDisplay {
  constructor(player) {
    this.player = player;
    this.lyrics = null;
    this.currentLineIndex = 0;
    this.displayInterval = null;
  }
  
  async start() {
    try {
      this.lyrics = await this.player.lyrics.getLyrics();
      
      if (!this.lyrics?.data?.synced) {
        console.log('‚ùå Nenhuma letra sincronizada dispon√≠vel');
        return;
      }
      
      this.displayInterval = setInterval(() => {
        this.updateDisplay();
      }, 100);
      
      // Parar exibi√ß√£o quando a faixa terminar
      this.player.once('trackEnd', () => this.stop());
    } catch (error) {
      console.error('Erro ao iniciar exibi√ß√£o de letras:', error);
    }
  }
  
  updateDisplay() {
    if (!this.lyrics || !this.player.playing) return;
    
    const currentTime = this.player.position;
    const lines = this.lyrics.data.data;
    
    // Encontre a linha atual com base no timestamp
    const newLineIndex = lines.findIndex((line, index) => {
      return currentTime >= line.startTime && 
             (index === lines.length - 1 || currentTime < lines[index + 1].startTime);
    });
    
    if (newLineIndex !== -1 && newLineIndex !== this.currentLineIndex) {
      this.currentLineIndex = newLineIndex;
      
      // Exibir linha atual e pr√≥xima linha
      console.clear();
      console.log('üéµ Tocando Agora:', this.player.current.title);
      console.log('\nLinha Atual:');
      console.log(lines[this.currentLineIndex].text);
      
      if (lines[this.currentLineIndex + 1]) {
        console.log('\nPr√≥xima Linha:');
        console.log(lines[this.currentLineIndex + 1].text);
      }
    }
  }
  
  stop() {
    if (this.displayInterval) {
      clearInterval(this.displayInterval);
      this.displayInterval = null;
    }
    this.lyrics = null;
    this.currentLineIndex = 0;
  }
}

// Uso
player.on('trackStart', async () => {
  const lyricsDisplay = new LyricsDisplay(player);
  await lyricsDisplay.start();
});
```
::

## Letras

::button-link{right-icon="lucide:arrow-right" to="/api/database"}
  Continuar para Banco de Dados
:: 
