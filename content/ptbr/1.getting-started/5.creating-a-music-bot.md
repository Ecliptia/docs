---
title: Criando um Bot de Música
description: "Aprenda como criar um bot de música simples com Moonlink.js"
icon: 'lucide:bot'
authors:
  - avatar: https://www.npmjs.com/npm-avatar/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdmF0YXJVUkwiOiJodHRwczovL3MuZ3JhdmF0YXIuY29tL2F2YXRhci9hNmE5NDVhYjJiNzk1MjcyNzVjN2IwMWEyNWM1YzQ2NT9zaXplPTQ5NiZkZWZhdWx0PXJldHJvIn0.5hP6oyShhR-UWUi6KF-lA0cWmE_BJjvIFAwkYCGEZNo
    name: Lucas Morais Rodrigues
    username: 1Lucas1apk
    to: https://github.com/1Lucas1apk
    target: _blank
---

::alert{type="info" icon="lucide:bot"}
Este guia irá orientá-lo no processo de criação de um bot de música simples, mas funcional, usando Moonlink.js e Discord.js. Ao final, você terá um bot que pode tocar música, gerenciar filas e responder a comandos básicos.
::

## Introdução

Agora que você configurou o Moonlink.js com seu bot do Discord, é hora de criar um bot de música totalmente funcional. Neste guia, construiremos um bot com as seguintes capacidades:

1. Conectar-se a um canal de voz quando solicitado
2. Tocar música do YouTube, SoundCloud e outras fontes suportadas
3. Lidar com controles básicos de reprodução (play, pause, resume, skip, stop)
4. Gerenciar uma fila de músicas para reprodução contínua

Este guia passo a passo ajudará você a entender como cada componente funciona em conjunto para criar uma experiência musical perfeita para o seu servidor do Discord.

## Pré-requisitos

Antes de começarmos a construir nosso bot de música, certifique-se de que você:

1. Instalou o Moonlink.js e suas dependências (conforme abordado no guia de Instalação)
2. Configurou o Lavalink e o tem em execução (conforme explicado no guia do Lavalink)
3. Criou um bot do Discord e o adicionou ao seu servidor com as permissões adequadas
4. Configurou a configuração básica do Moonlink.js (conforme mostrado no guia de Configuração Básica)

Se você não concluiu essas etapas, por favor, volte às seções anteriores antes de continuar.

## Estrutura do Projeto

Uma estrutura de projeto bem organizada torna seu código mais fácil de manter e entender. Vamos organizar nosso projeto de bot de música com a seguinte estrutura:

```
music-bot/
├── commands/           # Diretório para todos os arquivos de comando
│   ├── play.js         # Comando para tocar música
│   ├── skip.js         # Comando para pular a faixa atual
│   ├── stop.js         # Comando para parar a reprodução
│   ├── pause.js        # Comando para pausar a reprodução
│   ├── resume.js       # Comando para retomar a reprodução
│   └── queue.js        # Comando para exibir a fila atual
├── events/             # Diretório para arquivos de manipuladores de eventos
│   ├── ready.js        # Manipula o evento 'ready' do bot
│   ├── interactionCreate.js  # Manipula interações de comandos de barra
│   └── messageCreate.js      # Manipula comandos de mensagem
├── config.json         # Arquivo de configuração para as configurações do bot
└── index.js            # Ponto de entrada principal para o bot
```

Essa estrutura separa comandos e eventos em seus próprios diretórios, facilitando a adição, modificação ou remoção de funcionalidades conforme necessário.

## Passo 1: Configurando o Arquivo Principal

Primeiro, vamos criar o arquivo principal (`index.js`) que servirá como ponto de entrada para nosso bot. Este arquivo irá:

1. Inicializar o cliente do Discord
2. Configurar o gerenciador Moonlink.js
3. Carregar comandos e manipuladores de eventos
4. Conectar-se ao Discord

Aqui está um detalhamento passo a passo do código:

```js
// index.js
const { Client, GatewayIntentBits, Collection } = require('discord.js');
const { Manager } = require('moonlink.js');
const fs = require('fs');
const path = require('path');
const config = require('./config.json');

// Crie um novo cliente do Discord com as intents necessárias
// Intents determinam quais eventos seu bot pode receber
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
  ],
});

// Crie uma nova instância do Moonlink Manager
// Esta é a interface principal para interagir com o Lavalink
client.manager = new Manager({
  // Configure os nodes do Lavalink para se conectar
  nodes: [
    {
      host: config.lavalink.host,
      port: config.lavalink.port,
      password: config.lavalink.password,
      secure: config.lavalink.secure,
    },
  ],
  // Esta função envia atualizações de estado de voz para o Discord
  // É necessária para que o bot entre em canais de voz
  sendPayload: (guildId, payload) => {
    const guild = client.guilds.cache.get(guildId);
    if (guild) guild.shard.send(JSON.parse(payload));
  },
  autoPlay: true, // Toca automaticamente a próxima música da fila
});

// Configure uma coleção para armazenar comandos
client.commands = new Collection();

// Carregue os arquivos de comando do diretório de comandos
const commandFiles = fs.readdirSync('./commands').filter(file => file.endsWith('.js'));

// Registre cada comando na coleção
for (const file of commandFiles) {
  const command = require(`./commands/${file}`);
  client.commands.set(command.name, command);
}

// Carregue os arquivos de manipulador de eventos do diretório de eventos
const eventFiles = fs.readdirSync('./events').filter(file => file.endsWith('.js'));

// Registre cada manipulador de evento
for (const file of eventFiles) {
  const event = require(`./events/${file}`);
  if (event.once) {
    // Para eventos que devem ser acionados apenas uma vez
    client.once(event.name, (...args) => event.execute(...args, client));
  } else {
    // Para eventos que podem ser acionados várias vezes
    client.on(event.name, (...args) => event.execute(...args, client));
  }
}

// Manipule eventos brutos para atualizações de estado de voz
// Isso é crucial para que o Moonlink.js funcione corretamente
client.on('raw', (packet) => {
  client.manager.packetUpdate(packet);
});

// Faça login no Discord com o token do seu bot
client.login(config.token);
```

### Arquivo de Configuração

Crie um arquivo `config.json` para armazenar a configuração do seu bot:

```json
{
  "token": "SEU_TOKEN_DE_BOT_DO_DISCORD",
  "prefix": "!",
  "lavalink": {
    "host": "localhost",
    "port": 2333,
    "password": "youshallnotpass",
    "secure": false
  }
}
```

Substitua `SEU_TOKEN_DE_BOT_DO_DISCORD` pelo token real do seu bot no Portal do Desenvolvedor do Discord.

## Passo 2: Configurando os Manipuladores de Eventos

A seguir, vamos criar os arquivos de manipulador de eventos que responderão a vários eventos do Discord e do Moonlink.js.

### Manipulador de Evento Ready

O evento `ready` é disparado quando seu bot se conecta com sucesso ao Discord. É aqui que inicializaremos o gerenciador Moonlink.js:

```js
// events/ready.js
module.exports = {
  name: 'ready',
  once: true,
  execute(client) {
    console.log(`Logado como ${client.user.tag}`);
    
    // Inicialize o Moonlink Manager com o ID de usuário do bot
    // Isso é necessário para que o gerenciador funcione corretamente
    client.manager.init(client.user.id);
    console.log('Moonlink Manager inicializado');
  },
};
```

### Manipulador de Evento Message Create

Este manipulador de eventos processa comandos de mensagens de texto:

```js
// events/messageCreate.js
module.exports = {
  name: 'messageCreate',
  execute(message, client) {
    // Ignore mensagens de bots ou mensagens sem o prefixo
    const prefix = client.config?.prefix || '!';
    if (message.author.bot || !message.content.startsWith(prefix)) return;
    
    // Extraia o nome do comando e os argumentos
    const args = message.content.slice(prefix.length).trim().split(/ +/);
    const commandName = args.shift().toLowerCase();
    
    // Verifique se o comando existe
    const command = client.commands.get(commandName);
    if (!command) return;
    
    // Execute o comando
    try {
      command.execute(message, args, client);
    } catch (error) {
      console.error(error);
      message.reply('Ocorreu um erro ao executar esse comando.');
    }
  },
};
```

### Manipulador de Evento Interaction Create

Este manipulador processa comandos de barra (implementaremos isso mais tarde):

```js
// events/interactionCreate.js
module.exports = {
  name: 'interactionCreate',
  execute(interaction, client) {
    if (!interaction.isCommand()) return;
    
    const command = client.commands.get(interaction.commandName);
    if (!command) return;
    
    try {
      command.execute(interaction, client);
    } catch (error) {
      console.error(error);
      interaction.reply({
        content: 'Ocorreu um erro ao executar este comando!',
        ephemeral: true,
      });
    }
  },
};
```

## Passo 3: Configurando os Ouvintes de Eventos do Moonlink

O Moonlink.js emite vários eventos que precisamos manipular para que nosso bot de música funcione corretamente. Adicione esses ouvintes de eventos ao seu arquivo `index.js`:

```js
// Adicione isso ao seu arquivo index.js após criar o gerenciador

// Eventos de conexão do Node
client.manager.on('nodeConnect', (node) => {
  console.log(`Node ${node.identifier} conectado`);
});

client.manager.on('nodeDisconnect', (node) => {
  console.log(`Node ${node.identifier} desconectado`);
});

client.manager.on('nodeError', (node, error) => {
  console.error(`Node ${node.identifier} encontrou um erro:`, error);
});

// Eventos de reprodução
client.manager.on('trackStart', (player, track) => {
  // Envie uma mensagem quando uma faixa começar a tocar
  const channel = client.channels.cache.get(player.textChannelId);
  if (channel) {
    channel.send(`Tocando agora: **${track.title}**`);
  }
});

client.manager.on('trackEnd', (player, track) => {
  console.log(`Faixa terminada: ${track.title}`);
});

client.manager.on('queueEnd', (player) => {
  // Envie uma mensagem quando a fila terminar
  const channel = client.channels.cache.get(player.textChannelId);
  if (channel) {
    channel.send('Fila terminada. Desconectando em 30 segundos se nenhuma nova faixa for adicionada.');
  }
  
  // Desconecte após um atraso se nenhuma nova faixa for adicionada
  // Isso ajuda a economizar recursos quando o bot não está em uso
  setTimeout(() => {
    if (!player.playing && player.queue.size === 0) {
      player.destroy();
      if (channel) {
        channel.send('Desconectado por inatividade.');
      }
    }
  }, 30000); // 30 segundos
});
```

## Passo 4: Criando Comandos de Música

Agora, vamos criar os comandos básicos de música para nosso bot. Cada comando estará em seu próprio arquivo no diretório `commands`.

### Comando Play

O comando `play` é o comando mais importante para um bot de música. Ele permite que os usuários pesquisem e toquem música:

```js
// commands/play.js
module.exports = {
  name: 'play',
  description: 'Tocar uma música',
  async execute(message, args, client) {
    // Passo 1: Verifique se o usuário está em um canal de voz.
    // Isso é importante para garantir que o bot saiba onde entrar.
    const { channel } = message.member.voice;
    if (!channel) {
      return message.reply('Você precisa entrar em um canal de voz primeiro!');
    }
    
    // Passo 2: Verifique se uma consulta de pesquisa foi fornecida.
    // O bot precisa saber qual música pesquisar.
    if (!args.length) {
      return message.reply('Por favor, forneça uma música para tocar!');
    }
    
    // Passo 3: Crie um player para o servidor.
    // Se um player já existir, ele será recuperado. Caso contrário, um novo é criado.
    // Esta instância do player lida com tudo relacionado à música em um servidor específico.
    const player = client.manager.players.create({
      guildId: message.guild.id,
      voiceChannelId: channel.id,
      textChannelId: message.channel.id,
      autoPlay: true,
    });
    
    // Passo 4: Conecte-se ao canal de voz.
    // Isso estabelece a conexão para que o bot possa tocar áudio.
    player.connect();
    
    // Passo 5: Pesquise a faixa solicitada.
    // O Moonlink.js pesquisará na plataforma padrão (geralmente o YouTube).
    const query = args.join(' ');
    const searchResult = await client.manager.search({
      query: query,
      requester: message.author.id
    });
    
    // Passo 6: Lide com os resultados da pesquisa.
    // Primeiro, verifique se alguma faixa foi encontrada.
    if (!searchResult.tracks.length) {
      return message.reply('Nenhum resultado encontrado para sua consulta.');
    }
    
    // Passo 7: Processe os resultados com base no tipo de carregamento.
    // O loadType indica se uma playlist, uma única faixa ou um resultado de pesquisa foi retornado.
    switch (searchResult.loadType) {
      case 'playlist':
        // Se uma playlist for encontrada, adicione todas as suas faixas à fila.
        player.queue.add(searchResult.tracks);
        
        message.reply({
          content: `Adicionada a playlist **${searchResult.playlistInfo.name}** com ${searchResult.tracks.length} faixas à fila.`,
        });
        
        // Se o player não estiver tocando, inicie a reprodução.
        if (!player.playing) {
          player.play();
        }
        break;
        
      case 'search':
      case 'track':
        // Se uma única faixa ou um resultado de pesquisa for encontrado, adicione a primeira faixa à fila.
        player.queue.add(searchResult.tracks[0]);
        
        message.reply({
          content: `Adicionado **${searchResult.tracks[0].title}** à fila.`,
        });
        
        // Se o player não estiver tocando, inicie a reprodução.
        if (!player.playing) {
          player.play();
        }
        break;
        
      case 'empty':
        // Se nenhuma correspondência for encontrada para a consulta.
        message.reply('Nenhuma correspondência encontrada para sua consulta!');
        break;
        
      case 'error':
        // Se ocorrer um erro ao carregar a faixa.
        message.reply(`Ocorreu um erro ao carregar a faixa: ${searchResult.error || 'Erro desconhecido'}`);
        break;
    }
  },
};
```

### Comando Skip

O comando `skip` permite que os usuários pulem a faixa atualmente em reprodução:

```js
// commands/skip.js
module.exports = {
  name: 'skip',
  description: 'Pular a música atual',
  execute(message, args, client) {
    // Passo 1: Obtenha o player para o servidor atual.
    // Cada servidor tem sua própria instância de player única.
    const player = client.manager.players.get(message.guild.id);
    
    // Passo 2: Verifique se existe um player para este servidor.
    // Não podemos pular se não houver um player ativo.
    if (!player) {
      return message.reply('Não há nada tocando neste servidor!');
    }
    
    // Passo 3: Verifique se o usuário está no mesmo canal de voz que o bot.
    // Isso impede que usuários em outros canais controlem a música.
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz que o bot para usar este comando!');
    }
    
    // Passo 4: Verifique se há uma faixa tocando atualmente.
    if (!player.current) {
      return message.reply('Não há nada tocando no momento!');
    }
    
    // Passo 5: Pule a faixa atual.
    // Armazenamos a faixa atual para mencioná-la na mensagem de confirmação.
    const currentTrack = player.current;
    player.skip();
    
    // Passo 6: Informe o usuário que a faixa foi pulada.
    message.reply(`Pulada: **${currentTrack.title}**`);
  },
};
```

### Comando Stop

O comando `stop` para a reprodução e limpa a fila:

```js
// commands/stop.js
module.exports = {
  name: 'stop',
  description: 'Parar a reprodução e limpar a fila',
  execute(message, args, client) {
    // Passo 1: Obtenha o player para o servidor.
    const player = client.manager.players.get(message.guild.id);
    
    // Passo 2: Verifique se existe um player.
    if (!player) {
      return message.reply('Não há nada tocando neste servidor!');
    }
    
    // Passo 3: Verifique se o usuário está no mesmo canal de voz.
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz que o bot para usar este comando!');
    }
    
    // Passo 4: Pare a reprodução e limpe a fila.
    player.stop();
    player.queue.clear();
    
    // Passo 5: Informe o usuário.
    message.reply('Reprodução parada e fila limpa.');
  },
};
```

### Comando Pause

O comando `pause` pausa a faixa atualmente em reprodução:

```js
// commands/pause.js
module.exports = {
  name: 'pause',
  description: 'Pausar a música atual',
  execute(message, args, client) {
    // Passo 1: Obtenha o player para o servidor.
    const player = client.manager.players.get(message.guild.id);
    
    // Passo 2: Verifique se existe um player.
    if (!player) {
      return message.reply('Não há nada tocando neste servidor!');
    }
    
    // Passo 3: Verifique se o usuário está no mesmo canal de voz.
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz que o bot para usar este comando!');
    }
    
    // Passo 4: Verifique se o player já está pausado.
    if (player.paused) {
      return message.reply('O player já está pausado!');
    }
    
    // Passo 5: Pause o player.
    player.pause();
    
    // Passo 6: Informe o usuário.
    message.reply('Player pausado.');
  },
};
```

### Comando Resume

O comando `resume` retoma a reprodução se estiver pausada:

```js
// commands/resume.js
module.exports = {
  name: 'resume',
  description: 'Retomar a reprodução se estiver pausada',
  execute(message, args, client) {
    // Passo 1: Obtenha o player para o servidor.
    const player = client.manager.players.get(message.guild.id);
    
    // Passo 2: Verifique se existe um player.
    if (!player) {
      return message.reply('Não há nada tocando neste servidor!');
    }
    
    // Passo 3: Verifique se o usuário está no mesmo canal de voz.
    if (message.member.voice.channel?.id !== player.voiceChannelId) {
      return message.reply('Você precisa estar no mesmo canal de voz que o bot para usar este comando!');
    }
    
    // Passo 4: Verifique se o player está pausado.
    if (!player.paused) {
      return message.reply('O player não está pausado!');
    }
    
    // Passo 5: Retome o player.
    player.resume();
    
    // Passo 6: Informe o usuário.
    message.reply('Reprodução retomada.');
  },
};
```

### Comando Queue

O comando `queue` exibe a fila atual de músicas:

```js
const { EmbedBuilder } = require('discord.js');

module.exports = {
   name: 'queue',
   description: 'Mostrar a fila atual',
   execute(message, args, client) {
      // Passo 1: Obtenha o player para este servidor
      const player = client.manager.players.get(message.guild.id);

      // Passo 2: Verifique se há um player
      if (!player) {
         return message.reply('Não há nada tocando neste servidor!');
      }

      // Passo 3: Verifique if há faixas na fila
      if (!player.current && player.queue.size === 0) {
         return message.reply('Não há faixas na fila!');
      }

      // Passo 4: Formate a duração para exibição
      // Esta função auxiliar converte milissegundos para um formato legível
      const formatDuration = (ms) => {
         const seconds = Math.floor((ms / 1000) % 60);
         const minutes = Math.floor((ms / (1000 * 60)) % 60);
         const hours = Math.floor(ms / (1000 * 60 * 60));

         return `${hours ? `${hours}:` : ''}${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      };

      // Passo 5: Crie um embed para a fila
      // Embeds fornecem uma maneira agradável e formatada de exibir informações
      const embed = new EmbedBuilder()
              .setTitle('Fila Atual')
              .setColor('#0099ff');

      // Passo 6: Adicione a faixa atual ao embed
      if (player.current) {
         embed.setDescription(`**Tocando Agora:**\n[${player.current.title}](${player.current.url}) | `${formatDuration(player.current.duration)}``);
      }

      // Passo 7: Adicione as faixas da fila ao embed
      if (player.queue.size > 0) {
         const tracks = player.queue.tracks.map((track, index) => {
            return `${index + 1}. [${track.title}](${track.url}) | `${formatDuration(track.duration)}``;
         });

         embed.addFields({ 
            name: 'A Seguir:', 
            value: tracks.slice(0, 10).join('\n'), 
         });

         // Se houver mais de 10 faixas, adicione uma nota
         if (player.queue.size > 10) {
            embed.addFields({ 
               name: 'E mais...', 
               value: `${player.queue.size - 10} mais faixas na fila`,
            });
         }
      }

      // Passo 8: Envie o embed para o canal
      message.reply({ embeds: [embed] });
   },
};
```

## Passo 5: Executando o Bot

Agora que criamos todos os arquivos necessários, é hora de executar nosso bot. Siga estas etapas:

1. Certifique-se de que o Lavalink está em execução
   ```
   java -jar Lavalink.jar
   ```

2. Inicie seu bot:
   ```
   node index.js
   ```

Você deve ver uma saída indicando que seu bot fez login e que o Moonlink Manager foi inicializado.

## Passo 6: Testando o Bot

Quando seu bot estiver em execução, você pode testá-lo com os seguintes comandos:

- `!play <nome da música ou URL>` - Toque uma música ou adicione-a à fila
- `!skip` - Pule a música atual
- `!stop` - Pare a reprodução e limpe a fila
- `!pause` - Pause a música atual
- `!resume` - Retome a reprodução
- `!queue` - Mostre a fila atual

Tente cada comando para garantir que seu bot esteja funcionando corretamente. Aqui estão alguns exemplos:

- `!play never gonna give you up` - Toca o clássico de Rick Astley
- `!play https://www.youtube.com/watch?v=dQw4w9WgXcQ` - Toca a mesma música usando uma URL direta
- `!play https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M` - Toca uma playlist do Spotify (se você tiver um plugin do Spotify)

## Próximos Passos

Parabéns! Você criou um bot de música básico com o Moonlink.js. A partir daqui, você pode expandir sua funcionalidade adicionando:

1. Mais comandos como controle de volume, busca dentro das faixas e filtros de áudio
2. Implementando comandos de barra para uma melhor experiência do usuário
3. Adicionando tratamento de erros e logs para maior confiabilidade
4. Implementando um sistema de cargos de DJ para restringir certos comandos a usuários específicos
5. Adicionando suporte a playlists para salvar e carregar playlists

Na próxima seção, exploraremos como implementar esses comandos de música avançados para tornar seu bot ainda mais poderoso.

## Solução de Problemas Comuns

Se você encontrar problemas com seu bot, aqui estão alguns problemas e soluções comuns:

- **O bot não entra em canais de voz**: Certifique-se de que você configurou a função `sendPayload` corretamente e está manipulando eventos brutos.
- **Nenhum som está tocando**: Verifique se o Lavalink está em execução e configurado corretamente.
- **Erro ao conectar ao Lavalink**: Verifique seu host, porta e senha do Lavalink no arquivo de configuração.
- **Comandos não funcionando**: Garanta que seus arquivos de comando estejam no diretório correto e sejam exportados adequadamente.

Lembre-se de que construir um bot de música é uma tarefa complexa, e é normal encontrar problemas ao longo do caminho. Não hesite em verificar a documentação do Moonlink.js ou pedir ajuda na comunidade do Discord se você ficar preso.
